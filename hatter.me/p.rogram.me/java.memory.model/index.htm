<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Meta, title, CSS, favicons, etc. -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Java内存模型 - P.ROGRAM.ME</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/prettify/prettify.css" rel="stylesheet">
    <link href="/assets/scrollToTop/scrollToTop.css" rel="stylesheet">

    <!-- Documentation extras -->
    <link href="/assets/css/docs.css" rel="stylesheet">
    <link href="/assets/css/pygments-manni.css" rel="stylesheet">
    <!--[if lt IE 9]><script src="/assets/js/ie8-responsive-file-warning.js"></script><![endif]-->

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="/assets/js/html5shiv.js"></script>
      <script src="/assets/js/respond.min.js"></script>
    <![endif]-->

    <!-- Favicons -->
    
    
    <link rel="shortcut icon" href="/assets/img/favicon.p.png">
    
    
    
  </head>
  <body onload="prettyPrint();">
    <a class="sr-only" href="#content">Skip to main content</a>
    <a href="#top" id="toTop" style="z-index:999999;"></a>

    <!-- Docs master nav -->
    <header class="navbar navbar-inverse navbar-fixed-top bs-docs-nav" role="banner">
      <div class="container">
        <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="/" class="navbar-brand">P.ROGRAM.ME</a>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
        
          
          <ul class="nav navbar-nav ">
			
			  
			    
			    
			        <li >
		              <a href="/">首页</a>
		            </li>
		        
			  
			    
			    
		           
		           <li class="dropdown active">
		             <a href="#" class="dropdown-toggle" data-toggle="dropdown">Java <b class="caret"></b></a>
		             <ul class="dropdown-menu">
		             
		               
		               
		                 <li ><a href="/java.study.list/">Java工程师学习列表</a></li>
		               
		             
		               
		               
		                 <li class="divider"></li>
		               
		             
		               
		               
		                 <li class="active"><a href="/java.memory.model/">Java内存模型</a></li>
		               
		             
		               
		               
		                 <li ><a href="/jsr133.cookbook/">The JSR-133 Cookbook for Compiler Writers</a></li>
		               
		             
		               
		               
		                 <li class="divider"></li>
		               
		             
		               
		               
		                 <li ><a href="/java.link/">Java相关链接</a></li>
		               
		             
		             </ul>
		           </li>
		        
			  
			    
			    
		           
		           <li class="dropdown ">
		             <a href="#" class="dropdown-toggle" data-toggle="dropdown">HTML5 <b class="caret"></b></a>
		             <ul class="dropdown-menu">
		             
		               
		               
		                 <li ><a href="/html5.link/">HTML5相关链接</a></li>
		               
		             
		             </ul>
		           </li>
		        
			  
			    
			    
		           
		           <li class="dropdown ">
		             <a href="#" class="dropdown-toggle" data-toggle="dropdown">工具 <b class="caret"></b></a>
		             <ul class="dropdown-menu">
		             
		               
		               
		                 <li ><a href="/java.tool/">Java工具</a></li>
		               
		             
		               
		               
		                 <li ><a href="/hatters.java.tool/">Hatter的Java工具</a></li>
		               
		             
		               
		               
		                 <li ><a href="/3rd.java.tool/">第三方Java工具</a></li>
		               
		             
		               
		               
		                 <li class="divider"></li>
		               
		             
		               
		               
		                 <li ><a href="/hatters.tool/">Hatter的小工具</a></li>
		               
		             
		             </ul>
		           </li>
		        
			  
			    
			    
			        <li >
		              <a href="/recruitment/">招聘</a>
		            </li>
		        
			  
			
          </ul>
          
          
          <ul class="nav navbar-nav navbar-right">
			
			  
			    
			    
			        <li >
		              <a href="/about/">关于</a>
		            </li>
		        
			  
			
          </ul>
          
        </nav>
      </div>
    </header>

    

    
    <!-- Callout for the old docs link -->
    <div class="bs-old-docs">
      <div class="container">
        <p><em>目前文档还在编辑中。。。</em></p>

        
      </div>
    </div>
    


    <div class="container bs-docs-container">
      
      <!-- DOC BODY START
      ================================================== -->
      <div class="row">
        <div class="col-md-3">
          <div class="bs-sidebar hidden-print" role="complementary">
            <ul class="nav bs-sidenav">
              
                
                  <li>
                  
                  <a href="#background">背景</a>
                  
                  
                    <ul class="nav">
                    
                      
                      <li><a href="#background--somanymicroarch"> 种类繁多的微架构</a></li>
                    
                      
                      <li><a href="#background--multithread"> 多线程(并发)编程</a></li>
                    
                      
                      <li><a href="#background--compiler"> 编译器的各种优化</a></li>
                    
                      
                      <li><a href="#background--micromarch"> 微架构的各种优化</a></li>
                    
                    </ul>
                  
                  </li>
                
                  <li>
                  
                  <a href="#x86">微架构之x86</a>
                  
                  
                    <ul class="nav">
                    
                      
                      <li><a href="#x86--x86x64"> 发展历程</a></li>
                    
                      
                      <li><a href="#x86--cache"> CPU缓存</a></li>
                    
                      
                      <li><a href="#x86--mesi"> 缓存一致性</a></li>
                    
                      
                      <li><a href="#x86--falsesharing"> 伪共享</a></li>
                    
                      
                      <li><a href="#x86--qpi"> QPI</a></li>
                    
                      
                      <li><a href="#x86--reordering"> 指令重排</a></li>
                    
                      
                      <li><a href="#x86--liushuixian"> 流水线技术</a></li>
                    
                      
                      <li><a href="#x86--cpuqpi"> CPU访问内存及相关性能</a></li>
                    
                    </ul>
                  
                  </li>
                
                  <li>
                  
                  <a href="#javamemorymodel">Java内存模型</a>
                  
                  
                    <ul class="nav">
                    
                      
                      <li><a href="#javamemorymodel--mainmemandworkmem"> 内存模型</a></li>
                    
                      
                      <li><a href="#javamemorymodel--final"> final</a></li>
                    
                      
                      <li><a href="#javamemorymodel--volatile"> volatile</a></li>
                    
                      
                      <li><a href="#javamemorymodel--synchronized"> synchronized</a></li>
                    
                      
                      <li><a href="#javamemorymodel--contended"> @Contended</a></li>
                    
                    </ul>
                  
                  </li>
                
                  <li>
                  
                  <a href="#code">代码分析</a>
                  
                  
                    <ul class="nav">
                    
                      
                      <li><a href="#code--sample1"> Sample 1</a></li>
                    
                      
                      <li><a href="#code--sample2"> Sample 2</a></li>
                    
                    </ul>
                  
                  </li>
                
                  <li>
                  
                  <a href="#reference">参考资料</a>
                  
                  
                  </li>
                
              
              
            </ul>
          </div>
        </div>
        <div class="col-md-9" role="main">

          
            
              
              <!-- background
              ================================================== -->
              <div class="bs-docs-section">
                <div class="page-header">
                  <h1 id="background">背景</h1>
                </div>
                <p class="lead"><p>虽然计算机的发展历史也就短短的几十年，但计算机计算的发展却非常迅速，特别是现在已经出现了几十核的<code>CPU</code>，但芯片的时钟频率目前已是非常难以提升，芯片厂商也只有发展多核这条路了。对于程序员来说，如何在多核情况下充分利用好硬件资源写出能够“正确”的代码就显的尤为重要。</p>
<p>Java内存模型就是教人如果在并发编程的情况下写出“正确”的代码。导致程序员可能写出“不正确”的代码的因素很多，如编译器的优化、CPU高速缓存优化等。这些优化有些是软件实现的，有些是硬件实现的，而Java内存模型是通过一个抽象模型（用来屏蔽软件或硬件的具体实现）指导程序员写出并发“正确”的代码。</p>
</p>
                
                
                  
                    
                    <h3 id="background--somanymicroarch" style="padding-top:60px;"> 种类繁多的微架构</h3>
                    <table style="width:600px;" class="table table-bordered">
<tr><th class="active"> 微架构 </th><th class="active"> 设计 </th><th class="active"> 说明 </th></tr>
<tr><th class="active"> X86 </th><td> <code>CISC</code> </td><td> <code>IA32</code>,<code>AMD64</code>,<code>Intel64</code> </td></tr>
<tr><th class="active"> IA64 </th><td> <code>EPIC</code> </td><td>  </td></tr>
<tr><th class="active"> ARM </th><td> <code>RISC</code> </td><td>  </td></tr>
<tr><th class="active"> Power PC </th><td> <code>RISC</code> </td><td>  </td></tr>
<tr><th class="active"> ALPHA </th><td> <code>RISC</code> </td><td>  </td></tr>
<tr><th class="active"> PA-RISC </th><td> <code>RISC</code> </td><td>  </td></tr>
<tr><td colspan="4"> &hellip; </td></tr>
</table><p><em>EPIC相关介绍: <a href="ia64/HP_Integrity_document_02.pdf" target="_blank">Itanium 处理器系列的 EPIC 架构</a></em></p>

                  
                    
                    <h3 id="background--multithread" style="padding-top:60px;"> 多线程(并发)编程</h3>
                    
                  
                    
                    <h3 id="background--compiler" style="padding-top:60px;"> 编译器的各种优化</h3>
                    <p>下面是一个<code>C#</code>的关于<code>volatile</code>的例子：</p>
<pre class="prettyprint linenums"><code>class Test
{
    private bool _loop = true;

    public static void Main()
    {
        Test test1 = new Test();

        // Set _loop to false on another thread
        new Thread(() =&gt; { test1._loop = false;}).Start();

        // Poll the _loop field until it is set to false
        while (test1._loop == true) ;

        // The loop above will never terminate!
    }
}
</code></pre>
<p><span class="glyphicon glyphicon-eye-open" style="color:blue;"></span>请看以下循环代码：</p>
<pre><code>while (test1._loop == true) ;
</code></pre>
<p><span class="glyphicon glyphicon-exclamation-sign" style="color:red;"></span> 但有可能实现上运行如下的代码：</p>
<pre><code>if (test1._loop) { while (true); }
</code></pre>
<p><span class="glyphicon glyphicon-exclamation-sign" style="color:red;"></span> 即等同于编译后的循环代码汇编如下：</p>
<pre><code>00000068  test        eax,eax 
0000006a  jne         00000068
</code></pre>
<p><span class="glyphicon glyphicon-ok" style="color:green;"></span> 如果将<code>_loop</code>变量标记为<code>volatile</code>，那么生成的代码如下：</p>
<pre><code>00000064  cmp         byte ptr [eax+4],0 
00000068  jne         00000064
</code></pre>
<p>从上面的例子我们可以看到当一个变量是否标记为<code>volatile</code>会影响编译器生成的代码是否访问“缓存”(寄存器)，因为访问寄存器快于L1，且远远快于内存访问。</p>
<p><br>
<br  /><em>代码引用自：<a href="http://igoro.com/archive/volatile-keyword-in-c-memory-model-explained/" target="_blank">http://igoro.com/archive/volatile-keyword-in-c-memory-model-explained/</a></em></p>

                  
                    
                    <h3 id="background--micromarch" style="padding-top:60px;"> 微架构的各种优化</h3>
                    <p>The mainstream x86 and x64 processors implement a strong memory model where memory access is effectively volatile. So, a volatile field forces the compiler to avoid some high-level optimizations like hoisting a read out of a loop, but otherwise results in the same assembly code as a non-volatile read.</p>
<p>The Itanium processor implements a weaker memory model. To target Itanium, the JIT compiler has to use special instructions for volatile memory accesses: LD.ACQ and ST.REL, instead of LD and ST. Instruction LD.ACQ effectively says, “refresh my cache and then read a value” and ST.REL says, “write a value to my cache and then flush the cache to main memory”. LD and ST on the other hand may just access the processor’s cache, which is not visible to other processors.</p>
<h2><br><br></h2>
<h4>1. 初始状态</h4>
<p><img src=" /java.memory.model/ia64/mm/1-init.png"/></p>
<h2><br><br></h2>
<h4>2. 普通写</h4>
<p>A non-volatile write could just update the value in the thread’s cache, and not the value in main memory:</p>
<p><img src=" /java.memory.model/ia64/mm/2-write.png"/></p>
<h2><br><br></h2>
<h4>3. <code>volatile</code>写</h4>
<p>However, in C# all writes are volatile (unlike say in Java), regardless of whether you write to a volatile or a non-volatile field. So, the above situation actually never happens in C#.</p>
<p>A volatile write updates the thread’s cache, and then flushes the entire cache to main memory. If we were to now set the volatile field v to 11, both values u and v would get flushed to main memory:</p>
<p><img src=" /java.memory.model/ia64/mm/3-volatile-write.png"/></p>
<h2><br><br></h2>
<h4>4. 普通读</h4>
<p>Since all C# writes are volatile, you can think of all writes as going straight to main memory.</p>
<p>A regular, non-volatile read can read the value from the thread’s cache, rather than from main memory. Despite the fact that thread 1 set u to 11, when thread 2 reads u, it will still see value 10:</p>
<p><img src=" /java.memory.model/ia64/mm/4-read.png"/></p>
<h2><br><br></h2>
<h4>5. <code>volatile</code>读</h4>
<p>When you read a non-volatile field in C#, a non-volatile read occurs, and you may see a stale value from the thread’s cache. Or, you may see the updated value. Whether you see the old or the new value depends on your compiler and your processor.</p>
<p>Finally, let’s take a look at an example of a volatile read. Thread 2 will read the volatile field v:</p>
<p><img src=" /java.memory.model/ia64/mm/5-volatile-read.png"/></p>
<p><br>
<br  /><em>图片引用自：<a href="http://igoro.com/archive/volatile-keyword-in-c-memory-model-explained/" target="_blank">http://igoro.com/archive/volatile-keyword-in-c-memory-model-explained/</a></em></p>

                  
                
              </div>
            
              
              <!-- x86
              ================================================== -->
              <div class="bs-docs-section">
                <div class="page-header">
                  <h1 id="x86">微架构之x86</h1>
                </div>
                <p class="lead"><p><code>x86</code>是一个指令集架构家族，最早由英特尔在<code>Intel 8086</code> CPU上开发出来。该系列较早期的处理器名称是以数字来表示<code>80x86</code>。由于以<code>86</code>作为结尾，包括<code>Intel 8086</code>、<code>80186</code>、<code>80286</code>、<code>80386</code>以及<code>80486</code>，因此其架构被称为<code>x86</code>。</p>
</p>
                
                
                  
                    
                    <h3 id="x86--x86x64" style="padding-top:60px;"> 发展历程</h3>
                    <p><code>x86</code>架构于<code>1978年</code>推出的<code>Intel 8086</code>中央处理器中首度出现，它是从<code>Intel 8008</code>处理器中发展而来的，而<code>8008</code>则是发展自<code>Intel 4004</code>的。<code>8086</code>在三年后为<code>IBM PC</code>所选用，之后x86便成为了个人计算机的标准平台，成为了历来最成功的CPU架构。</p>
<p><code>8086</code>是<code>16位</code>处理器；直到<code>1985年</code> <code>32位</code>的<code>80386</code>的开发，这个架构都维持是<code>16位</code>。接着一系列的处理器表示了<code>32位</code>架构的细微改进，推出了数种的扩充，直到<code>2003年</code> <code>AMD</code>对于这个架构发展了<code>64位</code>的扩充，并命名为<code>AMD64</code>。后来英特尔也推出了与之兼容的处理器，并命名为<code>Intel 64</code>。两者一般被统称为<code>x86-64</code>或<code>x64</code>，开创了<code>x86</code>的<code>64位</code>时代。</p>
<p><em>英特尔在<code>1990年代</code>就与惠普合作提出了一种用在安腾系列处理器中的独立的<code>64位</code>架构，这种架构被称为<code>IA-64</code>。<code>IA-64</code>是一种崭新的系统，和x86架构完全没有相似性；不应该把它与<code>x86-64</code>或<code>x64</code>弄混。</em></p>

                  
                    
                    <h3 id="x86--cache" style="padding-top:60px;"> CPU缓存</h3>
                    <h4><code>Core 2</code> <code>L1 Cache</code>(容量<code>32K</code>，<code>8路</code>，缓存线<code>64字节</code>):</h4>
<p><img src=" /java.memory.model/x86/core2_l1_cache.png"/></p>
<p><em>图片引用自：<a href="http://duartes.org/gustavo/blog/post/intel-cpu-caches" target="_blank">http://duartes.org/gustavo/blog/post/intel-cpu-caches</a></em></p>
<p><br></p>
<h4>高速缓存<code>L1</code>,<code>L2</code>及<code>L3</code>的结构：</h4>
<p><img src="intel_4_core.png" /></p>
<p><br></p>
<h4>在<code>Linux</code>下查看高速缓存的信息：</h4>
<table style="width:800px;" class="table table-bordered">
<tr><th class="active" colspan="2"> <code>cat /sys/devices/system/cpu/cpu{N}/cache/index{N}/{?}</code> </th></tr>
<tr><th class="active"> level </th><td> <code>1</code>,<code>2</code>,<code>3</code> 分别代表 <code>L1</code>,<code>L2</code>,<code>L3</code> </td></tr>
<tr><th class="active"> type </th><td> <code>Data</code>或<code>Instruction</code>，只有<code>L1</code>才有<code>Instruction</code> </td></tr>
<tr><th class="active"> coherency_line_size </th><td> <code>缓存线</code>(<code>Cache Line</code>)大小 </td></tr>
<tr><th class="active"> number_of_sets </th><td> 是多少行 </td></tr>
<tr><th class="active"> ways_of_associativity </th><td> 一共有多少路 </td></tr>
<tr><th class="active"> size </th><td> <code>32K</code>缓存大小 (<code>== coherency_line_size * number_of_sets * ways_of_associativity</code>) </td></tr>
<tr><th class="active"> shared_cpu_list </th><td> 在哪几个“<code>CPU</code>”之间共享，逗号分隔方式枚举 </td></tr>
<tr><th class="active"> shared_cpu_map </th><td> 在哪几个“<code>CPU</code>”之间共享，十六进制表示 </td></tr>
</table>
                  
                    
                    <h3 id="x86--mesi" style="padding-top:60px;"> 缓存一致性</h3>
                    <p>在<code>x86</code>微架构下，高速缓存是保证一致性的，即只要程序读写内存地址即可保证一定是读到的最新值，且写入的值可被读到。这种一致性通过缓存一致性协议实现。</p>
<p>缓存一致性(<code>MESI</code>, <code>Modified Exclusive Shared Invalid</code>)协议，也称为伊利诺伊协议(<code>Illinois protocol</code>，由伊利诺伊大学香槟[<code>Urbana-Champaign</code>]分校开发)，被广泛用于缓存一致性和内存一致性。是支持缓存回写的最通用的一种协议。</p>
<p>在<code>MESI</code>协议中，每个缓存行有4个状态，可用2个bit表示，它们分别是：</p>
<table style="width:700px;" class="table table-bordered">
<tr><th class="active"> 状态 </th><th class="active"> 描述 </th></tr>
<tr><th class="active"> M(Modified) </th><td> 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本<code>Cache</code>中。 </td></tr>
<tr><th class="active"> E(Exclusive) </th><td> 这行数据有效，数据和内存中的数据一致，数据只存在于本<code>Cache</code>中。 </td></tr>
<tr><th class="active"> S(Shared) </th><td> 这行数据有效，数据和内存中的数据一致，数据存在于很多<code>Cache</code>中。 </td></tr>
<tr><th class="active"> I(Invalid) </th><td> 这行数据无效 </td></tr>
</table><p><code>MESI</code>状态迁移图：
<br  /><img src="mesi.jpg" /></p>
<p><em>其中<code>Intel</code>使用<a href="http://en.wikipedia.org/wiki/MESIF_protocol" target="_blank"><code>MESIF</code></a>，<code>AMD</code>使用<a href="http://en.wikipedia.org/wiki/MOESI_protocol" target="_blank"><code>MOESI</code></a></em></p>

                  
                    
                    <h3 id="x86--falsesharing" style="padding-top:60px;">伪共享(False Sharing)</h3>
                    <p><code>伪共享</code>是在多核CPU下才会出现的一种特殊的竞争访问内存的情况，即当两个在一个缓存线中的变量在被两个线程频繁修改的时候会出现大量<code>L1</code>, <code>L1 L2</code>或<code>L1 L2 L3</code>缓存失效。</p>
<p><img src="false_sharing.png" /></p>

                  
                    
                    <h3 id="x86--qpi" style="padding-top:60px;"> QPI</h3>
                    
                  
                    
                    <h3 id="x86--reordering" style="padding-top:60px;"> 指令重排</h3>
                    
                  
                    
                    <h3 id="x86--liushuixian" style="padding-top:60px;"> 流水线技术</h3>
                    
                  
                    
                    <h3 id="x86--cpuqpi" style="padding-top:60px;"> CPU访问内存及相关性能</h3>
                    <p><a href="intel_nehalem.png" target="_blank"><img src="intel_nehalem_800x800.png" /></a></p>

                  
                
              </div>
            
              
              <!-- javamemorymodel
              ================================================== -->
              <div class="bs-docs-section">
                <div class="page-header">
                  <h1 id="javamemorymodel">Java内存模型</h1>
                </div>
                <p class="lead"><p>我们先来看一段代码：</p>
<pre class="prettyprint linenums"><code>final class SetCheck {
  private int  a = 0;
  private long b = 0;

  void set() {
    a =  1;
    b = -1;
  }

  boolean check() {
    return ((b ==  0) ||
            (b == -1 &amp;&amp; a == 1)); 
  }
}
</code></pre>
<p><em>代码引用自：<a href="http://gee.cs.oswego.edu/dl/cpj/jmm.html" target="_blank">http://gee.cs.oswego.edu/dl/cpj/jmm.html</a></em></p>
</p>
                
                
                  
                    
                    <h3 id="javamemorymodel--mainmemandworkmem" style="padding-top:60px;"> 内存模型</h3>
                    <p><img src="jmm.png" /></p>

                  
                    
                    <h3 id="javamemorymodel--final" style="padding-top:60px;"> final</h3>
                    
                  
                    
                    <h3 id="javamemorymodel--volatile" style="padding-top:60px;"> volatile</h3>
                    <p><code>volatile</code>关键词是告诉编译器说“这个变量是易变的，请保证始终读、写唯一的值，并且请保证原子性”，当编译器接收到这些信息后，编译器会做如下处理：</p>
<ol>
<li>禁止编译器本身对该变量的读、写缓存优化</li>
<li>根据当前的微架构，在生成读、写该变量的硬件指令时禁止CPU的高速缓存<ul>
<li><code>X86</code>：微架构已经保证了缓存的强一致性，无须使用特别的指令</li>
<li><code>IA64</code>：使用<code>ld.acq</code>或<code>st.rel</code>指令进行读、写，保证CPU的高速缓存被更新</li>
</ul>
</li>
<li>禁止对这个变量读写前后的指令重排<ul>
<li><code>X86</code>：<code>mfence</code> or <code>cpuid</code> or <code>locked insn</code> (<code>lock; addl $0,0(%%esp)</code>)</li>
<li><code>IA64</code>：<code>mf</code></li>
</ul>
</li>
</ol>

                  
                    
                    <h3 id="javamemorymodel--synchronized" style="padding-top:60px;"> synchronized</h3>
                    
                  
                    
                    <h3 id="javamemorymodel--contended" style="padding-top:60px;"> @Contended</h3>
                    <p><code>@Contended</code>通过<a href="http://openjdk.java.net/jeps/142" target="_blank">JEP 142 (在特定字段上减少高速缓存竞争访问)</a>引入，即针对伪共享提供一种解决方案，解决方法是通过<code>@Contended</code>来标记哪些字段是竞争访问的，编译器在编译的时候即将存在竞争访问的字段对齐到不同的缓存线。</p>

                  
                
              </div>
            
              
              <!-- code
              ================================================== -->
              <div class="bs-docs-section">
                <div class="page-header">
                  <h1 id="code">代码分析</h1>
                </div>
                <p class="lead"></p>
                
                
                  
                    
                    <h3 id="code--sample1" style="padding-top:60px;"> Sample 1</h3>
                    <pre class="prettyprint linenums"><code>public class Sample {
  private static int count = 0;

  public static void increment() {
    count++;
  }
}
</code></pre>

                  
                    
                    <h3 id="code--sample2" style="padding-top:60px;"> Sample 2</h3>
                    <pre class="prettyprint linenums"><code>// 代码1
public class Sample {
  private static int count = 0;

  synchronized public static void increment() {
    count++;
  }
}

// 代码2
public class Sample {
  private static AtomicInteger count = new AtomicInteger(0);

  public static void increment() {
    count.getAndIncrement();
  }
}
</code></pre>

                  
                
              </div>
            
              
              <!-- reference
              ================================================== -->
              <div class="bs-docs-section">
                <div class="page-header">
                  <h1 id="reference">参考资料</h1>
                </div>
                <p class="lead"><ol>
<li><a href="https://jcp.org/en/jsr/detail?id=133" target="_blank">JSR 133: JavaTM Memory Model and Thread Specification Revision</a></li>
<li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank">JSR 133 (Java Memory Model) FAQ</a></li>
<li><a href="http://g.oswego.edu/dl/jmm/cookbook.html" target="_blank">The JSR-133 Cookbook for Compiler Writers</a></li>
<li><a href="http://en.wikipedia.org/wiki/Memory_ordering" target="_blank">Memory ordering</a></li>
<li><a href="http://zh.wikipedia.org/wiki/Itanium" target="_blank">Itanium</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E9%A1%AF%E5%BC%8F%E4%B8%A6%E8%A1%8C%E6%8C%87%E4%BB%A4%E9%81%8B%E7%AE%97" target="_blank">显式并行指令运算(EPIC)</a></li>
<li><a href="http://en.wikipedia.org/wiki/DEC_Alpha" target="_blank">DEC Alpha</a></li>
<li><a href="http://en.wikipedia.org/wiki/PA-RISC" target="_blank">PA-RISC</a></li>
<li><a href="http://docs.oracle.com/javase/specs/jls/se7/html/" target="_blank">The Java® Language Specification Java SE 7 Edition</a></li>
<li><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/" target="_blank">The Java® Virtual Machine Specification Java SE 7 Edition</a>1.</li>
<li><a href="http://gee.cs.oswego.edu/dl/cpj/jmm.html" target="_blank">Synchronization and the Java Memory Model</a></li>
<li><a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf" target="_blank">Common Language Infrastructure (CLI)</a></li>
<li><a href="http://blogs.msdn.com/b/jaredpar/archive/2008/01/17/clr-memory-model.aspx" target="_blank">CLR Memory Model</a></li>
<li><a href="http://joeduffyblog.com/2008/06/13/volatile-reads-and-writes-and-timeliness/" target="_blank">Volatile reads and writes, and timeliness</a></li>
<li><a href="http://blogs.msdn.com/b/cbrumme/archive/2003/05/17/51445.aspx" target="_blank">Memory Model</a></li>
<li><a href="http://joeduffyblog.com/2007/11/10/clr-20-memory-model/" target="_blank">CLR 2.0 memory model</a></li>
<li><a href="http://msdn.microsoft.com/en-us/magazine/cc163715.aspx" target="_blank">Understand the Impact of Low-Lock Techniques in Multithreaded Apps</a></li>
<li><a href="http://igoro.com/archive/volatile-keyword-in-c-memory-model-explained/" target="_blank">Volatile keyword in C# – memory model explained</a></li>
<li><a href="http://golang.org/ref/mem" target="_blank">The Go Memory Model</a></li>
<li><a href="http://duartes.org/gustavo/blog/post/intel-cpu-caches" target="_blank">Cache: a place for concealment and safekeeping</a></li>
<li><a href="http://blog.csdn.net/drshenlei/article/details/4277959" target="_blank">Cache：一个隐藏并保管数据的场所</a></li>
<li><a href="http://zh.wikipedia.org/wiki/X86" target="_blank">x86</a></li>
<li><a href="https://code.google.com/p/hatter-source-code/wiki/Study_CPU_MESI" target="_blank">Study_CPU_MESI</a></li>
<li><a href="https://code.google.com/p/hatter-source-code/wiki/Study_Java_HotSpot_Concurrent" target="_blank">Study_Java_HotSpot_Concurrent</a></li>
<li><a href="https://blogs.oracle.com/dave/entry/java_contented_annotation_to_help" target="_blank">Java @Contended annotation to help reduce false sharing</a></li>
<li><a href="http://openjdk.java.net/jeps/142" target="_blank">JEP 142: Reduce Cache Contention on Specified Fields</a></li>
</ol>
</p>
                
                
              </div>
            
          
          

          <!-- End Content
          ================================================== -->
        </div>
      </div>
      
      <!-- DOC BODY END
      ================================================== -->
    </div>

    <!-- Footer
    ================================================== -->
    <footer class="bs-footer" role="contentinfo">
      <div class="container">
        <p><em>P.ROGRAM.ME, Hatter Jiang's website <a href="http://hatter.me" target="_blank">http://hatter.me</a> 我们在<a href="http://p.rogram.me/recruitment/">招聘</a></em></p>

        
      </div>
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/assets/js/jquery.min.js"></script>
    <script src="/assets/js/bootstrap.js"></script>
    <script src="/assets/js/holder.js"></script>
    <script src="/assets/js/application.js"></script>
    <script src="/assets/prettify/prettify.js"></script>
    <script src="/assets/scrollToTop/jquery.scrollToTop.min.js"></script>
    <script type="text/javascript">
      $(function() {
        $("#toTop").scrollToTop();
      });
    </script>
  </body>
</html>

