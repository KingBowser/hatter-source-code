<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Meta, title, CSS, favicons, etc. -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Java内存模型 - P.ROGRAM.ME</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/prettify/prettify.css" rel="stylesheet">
    <link href="/assets/scrollToTop/scrollToTop.css" rel="stylesheet">

    <!-- Documentation extras -->
    <link href="/assets/css/docs.css" rel="stylesheet">
    <link href="/assets/css/pygments-manni.css" rel="stylesheet">
    <!--[if lt IE 9]><script src="/assets/js/ie8-responsive-file-warning.js"></script><![endif]-->

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="/assets/js/html5shiv.js"></script>
      <script src="/assets/js/respond.min.js"></script>
    <![endif]-->

    <!-- Favicons -->
    
    
    <link rel="shortcut icon" href="/assets/img/favicon.p.png">
    
    
    
  </head>
  <body onload="prettyPrint();">
    <a class="sr-only" href="#content">Skip to main content</a>
    <a href="#top" id="toTop" style="z-index:999999;"></a>

    <!-- Docs master nav -->
    <header class="navbar navbar-inverse navbar-fixed-top bs-docs-nav" role="banner">
      <div class="container">
        <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="/" class="navbar-brand">P.ROGRAM.ME</a>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
        
          
          <ul class="nav navbar-nav ">
			
			  
			    
			    
			        <li >
		              <a href="/">首页</a>
		            </li>
		        
			  
			    
			    
		           
		           <li class="dropdown active">
		             <a href="#" class="dropdown-toggle" data-toggle="dropdown">Java <b class="caret"></b></a>
		             <ul class="dropdown-menu">
		             
		               
		               
		                 <li ><a href="/java.study.list/">Java工程师学习列表</a></li>
		               
		             
		               
		               
		                 <li class="divider"></li>
		               
		             
		               
		               
		                 <li class="active"><a href="/java.memory.model/">Java内存模型</a></li>
		               
		             
		               
		               
		                 <li ><a href="/jsr133.cookbook/">The JSR-133 Cookbook for Compiler Writers</a></li>
		               
		             
		               
		               
		                 <li class="divider"></li>
		               
		             
		               
		               
		                 <li ><a href="/java.link/">Java相关链接</a></li>
		               
		             
		             </ul>
		           </li>
		        
			  
			    
			    
		           
		           <li class="dropdown ">
		             <a href="#" class="dropdown-toggle" data-toggle="dropdown">HTML5 <b class="caret"></b></a>
		             <ul class="dropdown-menu">
		             
		               
		               
		                 <li ><a href="/html5.link/">HTML5相关链接</a></li>
		               
		             
		             </ul>
		           </li>
		        
			  
			    
			    
		           
		           <li class="dropdown ">
		             <a href="#" class="dropdown-toggle" data-toggle="dropdown">工具 <b class="caret"></b></a>
		             <ul class="dropdown-menu">
		             
		               
		               
		                 <li ><a href="/java.tool/">Java工具</a></li>
		               
		             
		               
		               
		                 <li ><a href="/hatters.java.tool/">Hatter的Java工具</a></li>
		               
		             
		               
		               
		                 <li ><a href="/3rd.java.tool/">第三方Java工具</a></li>
		               
		             
		               
		               
		                 <li class="divider"></li>
		               
		             
		               
		               
		                 <li ><a href="/hatters.tool/">Hatter的小工具</a></li>
		               
		             
		             </ul>
		           </li>
		        
			  
			    
			    
			        <li >
		              <a href="/recruitment/">招聘</a>
		            </li>
		        
			  
			
          </ul>
          
          
          <ul class="nav navbar-nav navbar-right">
			
			  
			    
			    
			        <li >
		              <a href="/about/">关于</a>
		            </li>
		        
			  
			
          </ul>
          
        </nav>
      </div>
    </header>

    

    
    <!-- Callout for the old docs link -->
    <div class="bs-old-docs">
      <div class="container">
        <p><em>目前文档还在编辑中。。。</em></p>

        
      </div>
    </div>
    


    <div class="container bs-docs-container">
      
      <!-- DOC BODY START
      ================================================== -->
      <div class="row">
        <div class="col-md-3">
          <div class="bs-sidebar hidden-print" role="complementary">
            <ul class="nav bs-sidenav">
              
                
                  <li>
                  
                  <a href="#background">背景</a>
                  
                  
                    <ul class="nav">
                    
                      
                      <li><a href="#background--somanymicroarch"> 种类繁多的微架构</a></li>
                    
                      
                      <li><a href="#background--multithread"> 多线程(并行)编程</a></li>
                    
                      
                      <li><a href="#background--compiler"> 编译器优化举例</a></li>
                    
                      
                      <li><a href="#background--micromarch"> 微架构优化举例</a></li>
                    
                    </ul>
                  
                  </li>
                
                  <li>
                  
                  <a href="#x86">微架构之x86</a>
                  
                  
                    <ul class="nav">
                    
                      
                      <li><a href="#x86--x86x64"> 发展历程</a></li>
                    
                      
                      <li><a href="#x86--cache"> CPU缓存</a></li>
                    
                      
                      <li><a href="#x86--mesi"> 缓存一致性</a></li>
                    
                      
                      <li><a href="#x86--falsesharing"> 伪共享</a></li>
                    
                      
                      <li><a href="#x86--reordering"> 指令重排</a></li>
                    
                      
                      <li><a href="#x86--accessperformance"> CPU访问相关性能</a></li>
                    
                    </ul>
                  
                  </li>
                
                  <li>
                  
                  <a href="#javamemorymodel">Java内存模型</a>
                  
                  
                    <ul class="nav">
                    
                      
                      <li><a href="#javamemorymodel--mainmemandworkmem"> 内存模型</a></li>
                    
                      
                      <li><a href="#javamemorymodel--final"> final</a></li>
                    
                      
                      <li><a href="#javamemorymodel--volatile"> volatile</a></li>
                    
                      
                      <li><a href="#javamemorymodel--synchronized"> synchronized</a></li>
                    
                      
                      <li><a href="#javamemorymodel--contended"> @Contended</a></li>
                    
                    </ul>
                  
                  </li>
                
                  <li>
                  
                  <a href="#code">代码分析</a>
                  
                  
                    <ul class="nav">
                    
                      
                      <li><a href="#code--sample1"> Sample 1</a></li>
                    
                      
                      <li><a href="#code--sample2"> Sample 2</a></li>
                    
                      
                      <li><a href="#code--sample3"> Sample 3</a></li>
                    
                    </ul>
                  
                  </li>
                
                  <li>
                  
                  <a href="#reference">参考资料</a>
                  
                  
                  </li>
                
              
              
            </ul>
          </div>
        </div>
        <div class="col-md-9" role="main">

          
            
              
              <!-- background
              ================================================== -->
              <div class="bs-docs-section">
                <div class="page-header">
                  <h1 id="background">背景</h1>
                </div>
                <p class="lead"><p>虽然计算机的发展历史也就短短的几十年，但计算机计算的发展却非常迅速，特别是现在已经出现了几十核的<code>CPU</code>，但芯片的时钟频率目前已是非常难以提升，芯片厂商也只有发展多核这条路了。对于程序员来说，如何在多核情况下充分利用好硬件资源写出能够“正确”的代码就显的尤为重要。</p>
<p>Java内存模型就是教人如果在并发编程的情况下写出“正确”的代码。导致程序员可能写出“不正确”的代码的因素很多，如编译器的优化、CPU高速缓存优化等。这些优化有些是软件实现的，有些是硬件实现的，而Java内存模型是通过一个抽象模型（用来屏蔽软件或硬件的具体实现）指导程序员写出并发“正确”的代码。</p>
</p>
                
                
                  
                    
                    <h3 id="background--somanymicroarch" style="padding-top:60px;"> 种类繁多的微架构</h3>
                    <table style="width:600px;" class="table table-bordered">
<tr><th class="active"> 微架构 </th><th class="active"> 设计 </th><th class="active"> 说明 </th></tr>
<tr><th class="active"> X86 </th><td> <code>CISC</code> </td><td> <code>IA32 ➟ AMD64 ➟ Intel64</code> </td></tr>
<tr><th class="active"> IA64 </th><td> <code>EPIC</code> </td><td> <code>Intel</code> <code>HP</code> </td></tr>
<tr><th class="active"> ARM </th><td> <code>RISC</code> </td><td> <code>Advanced RISC Machine</code> </td></tr>
<tr><th class="active"> Power PC </th><td> <code>RISC</code> </td><td> <code>Apple–IBM–Motorola alliance</code> </td></tr>
<tr><th class="active"> ALPHA </th><td> <code>RISC</code> </td><td> &hellip; </td></tr>
<tr><th class="active"> PA-RISC </th><td> <code>RISC</code> </td><td> &hellip; </td></tr>
<tr><td colspan="4"> &hellip; </td></tr>
</table><p><em>EPIC相关介绍: <a href="ia64/HP_Integrity_document_02.pdf" target="_blank">Itanium 处理器系列的 EPIC 架构</a></em></p>

                  
                    
                    <h3 id="background--multithread" style="padding-top:60px;"> 多线程(并行)编程</h3>
                    <p>对于传统的单核处理器来说微架构层面不存在可见性的问题，因为因为CPU仅拥有一套高速缓存，不同线程不可能因此读到不同值。</p>
<p>并发和并行的区别就是一个处理器同时处理多个任务和多个处理器或者是多核的处理器同时处理多个不同的任务。前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生：</p>
<ul>
<li>并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。</li>
<li>并行(parallelism)是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。</li>
</ul>
<p><em>来个比喻：并发和并行的区别就是一个人同时吃三个馒头和三个人同时吃三个馒头。</em></p>
<p><img src="concurrentparalel.jpg" /></p>
<p><br>
<br  /><em>图片引用自：<a href="http://www.cnblogs.com/NickyYe/archive/2008/12/01/1344802.html" target="_blank">http://www.cnblogs.com/NickyYe/archive/2008/12/01/1344802.html</a></em></p>
<p>线程间并行运行的问题举例会在“微架构优化举例”中提到。</p>

                  
                    
                    <h3 id="background--compiler" style="padding-top:60px;"> 编译器优化举例</h3>
                    <p>下面是一个<code>C#</code>的关于<code>volatile</code>的例子：</p>
<pre class="prettyprint linenums"><code>class Test
{
    private bool _loop = true;

    public static void Main()
    {
        Test test1 = new Test();

        // Set _loop to false on another thread
        new Thread(() =&gt; { test1._loop = false;}).Start();

        // Poll the _loop field until it is set to false
        while (test1._loop == true) ;

        // The loop above will never terminate!
    }
}
</code></pre>
<p><span class="glyphicon glyphicon-eye-open" style="color:blue;"></span>请看以下循环代码：</p>
<pre><code>while (test1._loop == true) ;
</code></pre>
<p><span class="glyphicon glyphicon-exclamation-sign" style="color:red;"></span> 但有可能实现上运行如下的代码：</p>
<pre><code>if (test1._loop) { while (true); }
</code></pre>
<p><span class="glyphicon glyphicon-exclamation-sign" style="color:red;"></span> 即等同于编译后的循环代码汇编如下：</p>
<pre><code>00000068  test        eax,eax 
0000006a  jne         00000068
</code></pre>
<p><span class="glyphicon glyphicon-ok" style="color:green;"></span> 如果将<code>_loop</code>变量标记为<code>volatile</code>，那么生成的代码如下：</p>
<pre><code>00000064  cmp         byte ptr [eax+4],0 
00000068  jne         00000064
</code></pre>
<p>从上面的例子我们可以看到当一个变量是否标记为<code>volatile</code>会影响编译器生成的代码是否访问“缓存”(寄存器)，因为访问寄存器快于L1，且远远快于内存访问。</p>
<p><br>
<br  /><em>代码引用自：<a href="http://igoro.com/archive/volatile-keyword-in-c-memory-model-explained/" target="_blank">http://igoro.com/archive/volatile-keyword-in-c-memory-model-explained/</a></em></p>

                  
                    
                    <h3 id="background--micromarch" style="padding-top:60px;"> 微架构优化举例</h3>
                    <p><code>x86</code>和<code>x64</code>(<code>x86_64</code>)实现了强一致的内存模型，即所有的内存访问都已经是<code>volatile</code>的。所以<code>volatile</code>的字段会强制编译器避免做了些高级优化，如在一个循环中读写一个变量，生成的代码将会是一个非<code>volatile</code>的内存读（这种方式已经在上面举例说明）。</p>
<p>然而，安腾处理器实现了一个弱的内存模型。对于目标处理器如果是安腾的话，对于<code>volatile</code>内存访问编译器需要使用一些特别的指令：<code>ld.acq</code>和<code>st.red</code>替代<code>ld</code>和<code>st</code>。指令<code>ld.acq</code>的意思是说“请先刷新缓存并读入该值”，而指令<code>st.rel</code>是说“把值写入缓存，并将这个值刷新到主内存”。而<code>ld</code>和<code>st</code>指令仅访问处理器的缓存，而这个缓存对于别的处理器可能是不可见的。</p>
<p>下面我们看一下图例：</p>
<p><br></p>
<h4>1. 初始状态</h4>
<p><img src=" /java.memory.model/ia64/mm/1-init.png"/></p>
<p><br></p>
<h4>2. 普通写</h4>
<p>对于非<code>volatile</code>的写数据有可能是仅仅更新的当前线程所在处理器的缓存，而未更新该值到主内存中：</p>
<p><img src=" /java.memory.model/ia64/mm/2-write.png"/></p>
<p><br></p>
<h4>3. <code>volatile</code>写</h4>
<p>对于<code>volatile</code>写数据将会先写入当前线程所有处理器的缓存，然后即将对应的缓存数据刷新到主内存中。如，我们将字段<code>v</code>设置为<code>11</code>，那么变量值<code>u</code>、<code>v</code>都会被刷新到主内存中：</p>
<p><img src=" /java.memory.model/ia64/mm/3-volatile-write.png"/></p>
<p><br></p>
<h4>4. 普通读</h4>
<p>通常来说，对于非<code>volatile</code>读则仅从当前线程所在处理器的缓存读入值，而不是从主内存中。所以，即便线程1将<code>u</code>设置为<code>11</code>，而线程2在读<code>u</code>时，他也将只能读到<code>10</code>。</p>
<p><img src=" /java.memory.model/ia64/mm/4-read.png"/></p>
<p><br></p>
<h4>5. <code>volatile</code>读</h4>
<p>最后，我们看一个<code>volatile</code>读的例子。线程2通过<code>volatile</code>读到字段<code>v</code>的最新值：</p>
<p><img src=" /java.memory.model/ia64/mm/5-volatile-read.png"/></p>
<p><br>
<br  /><em>图片引用自：<a href="http://igoro.com/archive/volatile-keyword-in-c-memory-model-explained/" target="_blank">http://igoro.com/archive/volatile-keyword-in-c-memory-model-explained/</a></em></p>

                  
                
              </div>
            
              
              <!-- x86
              ================================================== -->
              <div class="bs-docs-section">
                <div class="page-header">
                  <h1 id="x86">微架构之x86</h1>
                </div>
                <p class="lead"><p><code>x86</code>是一个指令集架构家族，最早由英特尔在<code>Intel 8086</code> CPU上开发出来。该系列较早期的处理器名称是以数字来表示<code>80x86</code>。由于以<code>86</code>作为结尾，包括<code>Intel 8086</code>、<code>80186</code>、<code>80286</code>、<code>80386</code>以及<code>80486</code>，因此其架构被称为<code>x86</code>。</p>
</p>
                
                
                  
                    
                    <h3 id="x86--x86x64" style="padding-top:60px;"> 发展历程</h3>
                    <p><code>x86</code>架构于<code>1978年</code>推出的<code>Intel 8086</code>中央处理器中首度出现，它是从<code>Intel 8008</code>处理器中发展而来的，而<code>8008</code>则是发展自<code>Intel 4004</code>的。<code>8086</code>在三年后为<code>IBM PC</code>所选用，之后x86便成为了个人计算机的标准平台，成为了历来最成功的CPU架构。</p>
<p><code>8086</code>是<code>16位</code>处理器；直到<code>1985年</code> <code>32位</code>的<code>80386</code>的开发，这个架构都维持是<code>16位</code>。接着一系列的处理器表示了<code>32位</code>架构的细微改进，推出了数种的扩充，直到<code>2003年</code> <code>AMD</code>对于这个架构发展了<code>64位</code>的扩充，并命名为<code>AMD64</code>。后来英特尔也推出了与之兼容的处理器，并命名为<code>Intel 64</code>。两者一般被统称为<code>x86-64</code>或<code>x64</code>，开创了<code>x86</code>的<code>64位</code>时代。</p>
<p><em>英特尔在<code>1990年代</code>就与惠普合作提出了一种用在安腾系列处理器中的独立的<code>64位</code>架构，这种架构被称为<code>IA-64</code>。<code>IA-64</code>是一种崭新的系统，和x86架构完全没有相似性；不应该把它与<code>x86-64</code>或<code>x64</code>弄混。</em></p>

                  
                    
                    <h3 id="x86--cache" style="padding-top:60px;"> CPU缓存</h3>
                    <h4><code>Core 2</code> <code>L1 Cache</code>(容量<code>32K</code>，<code>8路</code>，缓存线<code>64字节</code>):</h4>
<p><img src=" /java.memory.model/x86/core2_l1_cache.png"/></p>
<p><em>图片引用自：<a href="http://duartes.org/gustavo/blog/post/intel-cpu-caches" target="_blank">http://duartes.org/gustavo/blog/post/intel-cpu-caches</a></em></p>
<p><br></p>
<h4>高速缓存<code>L1</code>,<code>L2</code>及<code>L3</code>的结构：</h4>
<p><img src="intel_4_core.png" /></p>
<p><br></p>
<h4>在<code>Linux</code>下查看高速缓存的信息：</h4>
<table style="width:800px;" class="table table-bordered">
<tr><th class="active" colspan="2"> <code>cat /sys/devices/system/cpu/cpu{N}/cache/index{N}/{?}</code> </th></tr>
<tr><th class="active"> level </th><td> <code>1</code>,<code>2</code>,<code>3</code> 分别代表 <code>L1</code>,<code>L2</code>,<code>L3</code> </td></tr>
<tr><th class="active"> type </th><td> <code>Data</code>或<code>Instruction</code>，只有<code>L1</code>才有<code>Instruction</code> </td></tr>
<tr><th class="active"> coherency_line_size </th><td> <code>缓存线</code>(<code>Cache Line</code>)大小 </td></tr>
<tr><th class="active"> number_of_sets </th><td> 是多少行 </td></tr>
<tr><th class="active"> ways_of_associativity </th><td> 一共有多少路 </td></tr>
<tr><th class="active"> size </th><td> <code>32K</code>缓存大小 (<code>== coherency_line_size * number_of_sets * ways_of_associativity</code>) </td></tr>
<tr><th class="active"> shared_cpu_list </th><td> 在哪几个“<code>CPU</code>”之间共享，逗号分隔方式枚举 </td></tr>
<tr><th class="active"> shared_cpu_map </th><td> 在哪几个“<code>CPU</code>”之间共享，十六进制表示 </td></tr>
</table>
                  
                    
                    <h3 id="x86--mesi" style="padding-top:60px;"> 缓存一致性</h3>
                    <p>在<code>x86</code>微架构下，高速缓存是保证一致性的，即只要程序读写内存地址即可保证一定是读到的最新值，且写入的值可被读到。这种一致性通过缓存一致性协议实现。</p>
<p>缓存一致性(<code>MESI</code>, <code>Modified Exclusive Shared Invalid</code>)协议，也称为伊利诺伊协议(<code>Illinois protocol</code>，由伊利诺伊大学香槟[<code>Urbana-Champaign</code>]分校开发)，被广泛用于缓存一致性和内存一致性。是支持缓存回写的最通用的一种协议。</p>
<p>在<code>MESI</code>协议中，每个缓存行有4个状态，可用2个bit表示，它们分别是：</p>
<table style="width:700px;" class="table table-bordered">
<tr><th class="active"> 状态 </th><th class="active"> 描述 </th></tr>
<tr><th class="active"> M(Modified) </th><td> 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本<code>Cache</code>中。 </td></tr>
<tr><th class="active"> E(Exclusive) </th><td> 这行数据有效，数据和内存中的数据一致，数据只存在于本<code>Cache</code>中。 </td></tr>
<tr><th class="active"> S(Shared) </th><td> 这行数据有效，数据和内存中的数据一致，数据存在于很多<code>Cache</code>中。 </td></tr>
<tr><th class="active"> I(Invalid) </th><td> 这行数据无效 </td></tr>
</table><p><code>MESI</code>状态迁移图：
<br  /><img src="mesi.jpg" /></p>
<p><em>其中<code>Intel</code>使用<a href="http://en.wikipedia.org/wiki/MESIF_protocol" target="_blank"><code>MESIF</code></a>，<code>AMD</code>使用<a href="http://en.wikipedia.org/wiki/MOESI_protocol" target="_blank"><code>MOESI</code></a></em></p>

                  
                    
                    <h3 id="x86--falsesharing" style="padding-top:60px;">伪共享(False Sharing)</h3>
                    <p><code>伪共享</code>是在多核CPU下才会出现的一种特殊的竞争访问内存的情况，即当两个在一个缓存线中的变量在被两个线程频繁修改的时候会出现大量<code>L1</code>, <code>L1 L2</code>或<code>L1 L2 L3</code>缓存失效。</p>
<h4>伪共享原理介绍：</h4>
<p><img src="false_sharing.png" /></p>
<h4>测试伪共享的代码：</h4>
<pre class="prettyprint linenums"><code>public final class FalseSharing
    implements Runnable
{
    public final static int NUM_THREADS = 4; // change
    public final static long ITERATIONS = 500L * 1000L * 1000L;
    private final int arrayIndex;

    private static VolatileLong[] longs = new VolatileLong[NUM_THREADS];
    static
    {
        for (int i = 0; i &lt; longs.length; i++)
        {
            longs[i] = new VolatileLong();
        }
    }

    public FalseSharing(final int arrayIndex)
    {
        this.arrayIndex = arrayIndex;
    }

    public static void main(final String[] args) throws Exception
    {
        final long start = System.nanoTime();
        runTest();
        System.out.println("duration = " + (System.nanoTime() - start));
    }

    private static void runTest() throws InterruptedException
    {
        Thread[] threads = new Thread[NUM_THREADS];

        for (int i = 0; i &lt; threads.length; i++)
        {
            threads[i] = new Thread(new FalseSharing(i));
        }

        for (Thread t : threads)
        {
            t.start();
        }

        for (Thread t : threads)
        {
            t.join();
        }
    }

    public void run()
    {
        long i = ITERATIONS + 1;
        while (0 != --i)
        {
            longs[arrayIndex].value = i;
        }
    }

    public final static class VolatileLong
    {
        public volatile long value = 0L;
        public long p1, p2, p3, p4, p5, p6; // comment out
    }
}
</code></pre>
<h4>伪共享是否做padding的测试结果：</h4>
<p><img src="false_share_test_result.png" /></p>
<p><br>
<br  />图片及代码引用自：<a href="http://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html" target="_blank">http://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html</a></p>

                  
                    
                    <h3 id="x86--reordering" style="padding-top:60px;"> 指令重排</h3>
                    <p>我们知道现代CPU的主频越来越高，与cache的交互次数也越来越多。当CPU的计算速度远远超过访问cache时，会产生cache wait，过多的cache  wait就会造成性能瓶颈。
<br  />针对这种情况，多数架构（包括X86）采用了一种将cache分片的解决方案，即将一块cache划分成互不关联地多个 slots (逻辑存储单元，又名 Memory Bank 或 Cache Bank)，CPU可以自行选择在多个idle bank中进行存取。这种SMP的设计，显著提高了CPU的并行处理能力，也回避了cache访问瓶颈。</p>
<h5>Memory Bank的划分：</h5>
<ul>
<li>一般 Memory bank 是按cache address来划分的。比如 偶数adress 0×12345000 分到 bank 0, 奇数address 0×12345100 分到 bank1。</li>
</ul>
<h5>重排序的种类：</h5>
<ul>
<li>编译期重排：编译源代码时，编译器依据对上下文的分析，对指令进行重排序，以之更适合于CPU的并行执行。</li>
<li>运行期重排：CPU在执行过程中，动态分析依赖部件的效能，对指令做重排序优化。</li>
</ul>
<h5>多处理器(含多核和超线程)系统中的指令重排遵循以下规则：</h5>
<ul>
<li>Individual processors use the same ordering principles as in a single-processor system.</li>
<li>Writes by a single processor are observed in the same order by all processors.</li>
<li>Writes from an individual processor are NOT ordered with respect to the writes from other processors.</li>
<li>Memory ordering obeys causality (memory ordering respects transitive visibility).</li>
<li>Any two stores are seen in a consistent order by processors other than those performing the stores</li>
<li>Locked instructions have a total order.</li>
</ul>
<p><em><code>x86</code>指令重排详见：<code>8.2 MEMORY ORDERING</code>: <a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf" target="_blank">Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide, Part 1</a></em></p>

                  
                    
                    <h3 id="x86--accessperformance" style="padding-top:60px;"> CPU访问相关性能</h3>
                    <p><a href="intel_nehalem.png" target="_blank"><img src="intel_nehalem_800x800.png" /></a></p>

                  
                
              </div>
            
              
              <!-- javamemorymodel
              ================================================== -->
              <div class="bs-docs-section">
                <div class="page-header">
                  <h1 id="javamemorymodel">Java内存模型</h1>
                </div>
                <p class="lead"><p>我们先来看一段代码：</p>
<pre class="prettyprint linenums"><code>final class SetCheck {
  private int  a = 0;
  private long b = 0;

  void set() {
    a =  1;
    b = -1;
  }

  boolean check() {
    return ((b ==  0) ||
            (b == -1 &amp;&amp; a == 1)); 
  }
}
</code></pre>
<p><em>代码引用自：<a href="http://gee.cs.oswego.edu/dl/cpj/jmm.html" target="_blank">http://gee.cs.oswego.edu/dl/cpj/jmm.html</a></em></p>
</p>
                
                
                  
                    
                    <h3 id="javamemorymodel--mainmemandworkmem" style="padding-top:60px;"> 内存模型</h3>
                    <p><img src="jmm.png" /></p>
<h3>原子性</h3>
<p>某些指令的执行是需要有不可分割的效果的（执行不可打断）。为了这样的模型，该规则仅用于简单的读、写内存单元，包含了实例及静态字段（当然也包含数组元素），但不包含在函数中的局部变量。</p>
<h3>可见性</h3>
<p>在一个线程写入变量后另外一个线程需要对该变化可见。效果是当一个线程写入一个字段后，另外一个线程需要对这个字段可见（写入的最新值）。</p>
<h3>重排序</h3>
<p>任意一个线程都可能表现的乱序执行。而排序问题也总是围绕赋值语句的读、写顺序。</p>
<h3>happen-before</h3>
<ol>
<li>同一个线程中的每个<code>Action</code>都<code>happens-before</code>于出现在其后的任何一个<code>Action</code>。</li>
<li>对一个监视器的解锁<code>happens-before</code>于每一个后续对同一个监视器的加锁。</li>
<li>对<code>volatile</code>字段的写入操作<code>happens-before</code>于每一个后续的同一个字段的读操作。</li>
<li><code>Thread.start()</code>的调用会<code>happens-before</code>于启动线程里面的动作。</li>
<li><code>Thread</code>中的所有动作都<code>happens-before</code>于其他线程检查到此线程结束或者<code>Thread.join()</code>中返回或者<code>Thread.isAlive()==false</code>。</li>
<li>一个线程<code>A</code>调用另一个另一个线程B的<code>interrupt()</code>都<code>happens-before</code>于线程<code>A</code>发现<code>B</code>被<code>A</code>中断（<code>B</code>抛出异常或者<code>A</code>检测到<code>B</code>的<code>isInterrupted()</code>或者<code>interrupted()</code>）。</li>
<li>一个对象构造函数的结束<code>happens-before</code>与该对象的<code>finalizer</code>的开始</li>
<li>如果A动作<code>happens-before</code>于<code>B</code>动作，而B动作<code>happens-before</code>与<code>C</code>动作，那么<code>A</code>动作<code>happens-before</code>于<code>C</code>动作。</li>
</ol>

                  
                    
                    <h3 id="javamemorymodel--final" style="padding-top:60px;"> final</h3>
                    
                  
                    
                    <h3 id="javamemorymodel--volatile" style="padding-top:60px;"> volatile</h3>
                    <p><code>volatile</code>关键词是告诉编译器说“这个变量是易变的，请保证始终读、写唯一的值，并且请保证原子性”，当编译器接收到这些信息后，编译器会做如下处理：</p>
<ol>
<li>禁止编译器本身对该变量的读、写缓存优化</li>
<li>根据当前的微架构，在生成读、写该变量的硬件指令时禁止CPU的高速缓存<ul>
<li><code>X86</code>：微架构已经保证了缓存的强一致性，无须使用特别的指令</li>
<li><code>IA64</code>：使用<code>ld.acq</code>或<code>st.rel</code>指令进行读、写，保证CPU的高速缓存被更新</li>
</ul>
</li>
<li>禁止对这个变量读写前后的指令重排<ul>
<li><code>X86</code>：<code>mfence</code> or <code>cpuid</code> or <code>locked insn</code> (<code>lock; addl $0,0(%%esp)</code>)</li>
<li><code>IA64</code>：<code>mf</code></li>
</ul>
</li>
</ol>
<p>对于原子性、可见性和重排序来说，定义一个<code>volatile</code>的字段的作用等价于下面这样的类（定义一个<code>synchronized</code>保护的使用<code>get</code>/<code>set</code>方法访问的类）：</p>
<pre class="prettyprint linenums"><code>final class VFloat {
  private float value;

  final synchronized void  set(float f) { value = f; }
  final synchronized float get()        { return value; }
}
</code></pre>
<p><br>
<br  /><em>代码引用自：http://gee.cs.oswego.edu/dl/cpj/jmm.html</em></p>

                  
                    
                    <h3 id="javamemorymodel--synchronized" style="padding-top:60px;"> synchronized</h3>
                    <p><code>synchronized</code>的锁原理及优化详见：<a href="https://code.google.com/p/hatter-source-code/wiki/Study_Java_HotSpot_Concurrent" target="_blank">Study_Java_HotSpot_Concurrent</a></p>

                  
                    
                    <h3 id="javamemorymodel--contended" style="padding-top:60px;"> @Contended</h3>
                    <p><span class="glyphicon glyphicon-thumbs-down" style="color:red;"></span> <code>sun.misc.Contended</code></p>
<p><code>@Contended</code>通过<a href="http://openjdk.java.net/jeps/142" target="_blank">JEP 142 (在特定字段上减少高速缓存竞争访问)</a>引入，即针对伪共享提供一种解决方案，解决方法是通过<code>@Contended</code>来标记哪些字段是竞争访问的，编译器在编译的时候即将存在竞争访问的字段对齐到不同的缓存线。</p>
<p>Sample代码<code>jdk/src/share/classes/java/lang/Thread.java</code>：</p>
<pre class="prettyprint"><code>2034     // The following three initially uninitialized fields are exclusively
2035     // managed by class java.util.concurrent.ThreadLocalRandom. Additionally,
2036     // these fields are isolated from other fields in Thread due to being
2037     // heavily updated.
2038     /** The current seed for a ThreadLocalRandom */
2039     @sun.misc.Contended("tlr")
2040     long threadLocalRandomSeed;
2041     /** Probe hash value; nonzero if threadLocalRandomSeed initialized */
2042     @sun.misc.Contended("tlr")
2043     int threadLocalRandomProbe;
2044     /** Secondary seed isolated from public ThreadLocalRandom sequence */
2045     @sun.misc.Contended("tlr")
2046     int threadLocalRandomSecondarySeed;
</code></pre>

                  
                
              </div>
            
              
              <!-- code
              ================================================== -->
              <div class="bs-docs-section">
                <div class="page-header">
                  <h1 id="code">代码分析</h1>
                </div>
                <p class="lead"></p>
                
                
                  
                    
                    <h3 id="code--sample1" style="padding-top:60px;"> Sample 1</h3>
                    <h4>源代码：</h4>
<pre class="prettyprint linenums"><code>public class Sample {
  private static int count = 0;

  public static void increment() {
    count++;
  }
}
</code></pre>

                  
                    
                    <h3 id="code--sample2" style="padding-top:60px;"> Sample 2</h3>
                    <h4>源代码：</h4>
<pre class="prettyprint linenums"><code>// 代码1
public class Sample {
  private static int count = 0;

  synchronized public static void increment() {
    count++;
  }
}

// 代码2
public class Sample {
  private static AtomicInteger count = new AtomicInteger(0);

  public static void increment() {
    count.getAndIncrement();
  }
}
</code></pre>

                  
                    
                    <h3 id="code--sample3" style="padding-top:60px;"> Sample 3</h3>
                    <h4>源代码：</h4>
<pre class="prettyprint linenums"><code>public class CacheTest {

    public static void main(String[] args) {
        int[] arr = new int[64 * 1024 * 1024];
        for (int _loop = 0; _loop &lt; 10; _loop++) {
            System.out.print("Round: " + _loop);
            {
                long s = System.currentTimeMillis();
                for (int i = 0; i &lt; arr.length; i++) {
                    arr[i] *= 3;
                }
                System.out.print("\t" + (System.currentTimeMillis() - s) + " ms");
            }
            {
                long s = System.currentTimeMillis();
                for (int i = 0; i &lt; arr.length; i += 8) {
                    arr[i] *= 3;
                }
                System.out.print("\t" + (System.currentTimeMillis() - s) + " ms");
            }
            {
                long s = System.currentTimeMillis();
                for (int i = 0; i &lt; arr.length; i += 16) {
                    arr[i] *= 3;
                }
                System.out.print("\t" + (System.currentTimeMillis() - s) + " ms");
            }
            {
                long s = System.currentTimeMillis();
                for (int i = 0; i &lt; arr.length; i += 32) {
                    arr[i] *= 3;
                }
                System.out.print("\t" + (System.currentTimeMillis() - s) + " ms");
            }
            System.out.println();
        }
    }
}
</code></pre>
<h4>测试结果如下：</h4>
<p>从下面的结果可以看到只有到了第4列消耗的时间大幅减少(测试数据在我的MBP上得到)。为什么呢？</p>
<pre class="prettyprint linenums"><code>Round: 0  164 ms  135 ms  132 ms  90 ms
Round: 1  169 ms  136 ms  147 ms  103 ms
Round: 2  140 ms  131 ms  131 ms  83 ms
Round: 3  141 ms  131 ms  133 ms  82 ms
Round: 4  165 ms  140 ms  134 ms  84 ms
Round: 5  172 ms  135 ms  129 ms  89 ms
Round: 6  143 ms  149 ms  129 ms  93 ms
Round: 7  140 ms  136 ms  130 ms  88 ms
Round: 8  137 ms  136 ms  129 ms  86 ms
Round: 9  137 ms  131 ms  132 ms  82 ms
</code></pre>
<h4>K与响应时间的关系：</h4>
<p><img src="sample3_k.png" /></p>
<p><br>
<br  /><em>图片及代码引用自：<a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank">http://igoro.com/archive/gallery-of-processor-cache-effects/</a></em></p>

                  
                
              </div>
            
              
              <!-- reference
              ================================================== -->
              <div class="bs-docs-section">
                <div class="page-header">
                  <h1 id="reference">参考资料</h1>
                </div>
                <p class="lead"><ol>
<li><a href="https://jcp.org/en/jsr/detail?id=133" target="_blank">JSR 133: JavaTM Memory Model and Thread Specification Revision</a></li>
<li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank">JSR 133 (Java Memory Model) FAQ</a></li>
<li><a href="http://g.oswego.edu/dl/jmm/cookbook.html" target="_blank">The JSR-133 Cookbook for Compiler Writers</a></li>
<li><a href="http://en.wikipedia.org/wiki/Memory_ordering" target="_blank">Memory ordering</a></li>
<li><a href="http://zh.wikipedia.org/wiki/Itanium" target="_blank">Itanium</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E9%A1%AF%E5%BC%8F%E4%B8%A6%E8%A1%8C%E6%8C%87%E4%BB%A4%E9%81%8B%E7%AE%97" target="_blank">显式并行指令运算(EPIC)</a></li>
<li><a href="http://en.wikipedia.org/wiki/DEC_Alpha" target="_blank">DEC Alpha</a></li>
<li><a href="http://en.wikipedia.org/wiki/PA-RISC" target="_blank">PA-RISC</a></li>
<li><a href="http://docs.oracle.com/javase/specs/jls/se7/html/" target="_blank">The Java® Language Specification Java SE 7 Edition</a></li>
<li><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/" target="_blank">The Java® Virtual Machine Specification Java SE 7 Edition</a></li>
<li><a href="http://gee.cs.oswego.edu/dl/cpj/jmm.html" target="_blank">Synchronization and the Java Memory Model</a></li>
<li><a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf" target="_blank">Common Language Infrastructure (CLI)</a></li>
<li><a href="http://blogs.msdn.com/b/jaredpar/archive/2008/01/17/clr-memory-model.aspx" target="_blank">CLR Memory Model</a></li>
<li><a href="http://joeduffyblog.com/2008/06/13/volatile-reads-and-writes-and-timeliness/" target="_blank">Volatile reads and writes, and timeliness</a></li>
<li><a href="http://blogs.msdn.com/b/cbrumme/archive/2003/05/17/51445.aspx" target="_blank">Memory Model</a></li>
<li><a href="http://joeduffyblog.com/2007/11/10/clr-20-memory-model/" target="_blank">CLR 2.0 memory model</a></li>
<li><a href="http://msdn.microsoft.com/en-us/magazine/cc163715.aspx" target="_blank">Understand the Impact of Low-Lock Techniques in Multithreaded Apps</a></li>
<li><a href="http://igoro.com/archive/volatile-keyword-in-c-memory-model-explained/" target="_blank">Volatile keyword in C# – memory model explained</a></li>
<li><a href="http://golang.org/ref/mem" target="_blank">The Go Memory Model</a></li>
<li><a href="http://duartes.org/gustavo/blog/post/intel-cpu-caches" target="_blank">Cache: a place for concealment and safekeeping</a></li>
<li><a href="http://blog.csdn.net/drshenlei/article/details/4277959" target="_blank">Cache：一个隐藏并保管数据的场所</a></li>
<li><a href="http://zh.wikipedia.org/wiki/X86" target="_blank">x86</a></li>
<li><a href="https://code.google.com/p/hatter-source-code/wiki/Study_CPU_MESI" target="_blank">Study_CPU_MESI</a></li>
<li><a href="https://code.google.com/p/hatter-source-code/wiki/Study_Java_HotSpot_Concurrent" target="_blank">Study_Java_HotSpot_Concurrent</a></li>
<li><a href="https://blogs.oracle.com/dave/entry/java_contented_annotation_to_help" target="_blank">Java @Contended annotation to help reduce false sharing</a></li>
<li><a href="http://openjdk.java.net/jeps/142" target="_blank">JEP 142: Reduce Cache Contention on Specified Fields</a></li>
<li><a href="http://en.wikipedia.org/wiki/PowerPC" target="_blank">PowerPC</a></li>
<li><a href="http://zh.wikipedia.org/wiki/ARM%E6%9E%B6%E6%A7%8B" target="_blank">ARM架构</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%AE%89%E8%AC%80%E5%9C%8B%E9%9A%9B%E7%A7%91%E6%8A%80" target="_blank">ARM Holdings</a></li>
<li><a href="http://developer.51cto.com/art/200908/141553.htm" target="_blank">并发和并行的区别：吃馒头的比喻</a></li>
<li><a href="http://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html" target="_blank">False Sharing</a></li>
<li><a href="http://www.cnblogs.com/vipper/p/3307991.html" target="_blank">happens-before规则和指令重排</a></li>
<li><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" target="_blank">Intel® 64 and IA-32 Architectures Software Developer Manuals</a></li>
</ol>
</p>
                
                
              </div>
            
          
          

          <!-- End Content
          ================================================== -->
        </div>
      </div>
      
      <!-- DOC BODY END
      ================================================== -->
    </div>

    <!-- Footer
    ================================================== -->
    <footer class="bs-footer" role="contentinfo">
      <div class="container">
        <p><em>P.ROGRAM.ME, Hatter Jiang's website <a href="http://hatter.me" target="_blank">http://hatter.me</a> 我们在<a href="http://p.rogram.me/recruitment/">招聘</a></em></p>

        
      </div>
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/assets/js/jquery.min.js"></script>
    <script src="/assets/js/bootstrap.js"></script>
    <script src="/assets/js/holder.js"></script>
    <script src="/assets/js/application.js"></script>
    <script src="/assets/prettify/prettify.js"></script>
    <script src="/assets/scrollToTop/jquery.scrollToTop.min.js"></script>
    <script type="text/javascript">
      $(function() {
        $("#toTop").scrollToTop();
      });
    </script>
  </body>
</html>

