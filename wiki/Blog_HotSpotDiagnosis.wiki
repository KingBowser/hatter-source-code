#summary HotSpot问题诊断
#sidebar TableOfContents

=HotSpot问题诊断=
查找HotSpot相关的问题需要根据现象判断，对现象简单分类如下：

==一、HotSpot异常退出==
这个问题比较棘手，因为通常JVM异常退出是JVM自身的Bug，所以一般需要读懂JVM源代码才能够找到/解决这类Bug。

==二、加载的类似乎有问题==
常常在一个应用里有同一个jar包的不同版本，但我们无法断定当前JVM加载的是哪个版本，这时候可以通过 `classdump` 打印URLClassLoader中加载的所有jar包，并列出他们的顺序。而我们实现的使用场景中常常还会使用类增强的手段，如使用ASM、javasist等，这时候需要分析内存中的字节码，此时也可以使用 `classdump` 将对应的类输出到磁盘文件。

==三、应用停止处理业务逻辑==
这种情况需要查看服务器Load是不是Load过高导致不处理正常业务逻辑，参看 `[应用Load过高]` 或 `[应用占用内存过高]` 。如果Load正常且内存占用也正常则需要通过命令 `jstack` 查看堆栈情况，分析程序未正常工作的原因。此类情况有可能是：
 * 数据库锁，更新/查询/删除数据未提交
 * 程序死锁，不恰当的使用Lock
 * 网络IO操作未返回，如未设置超时时间且当网络异常时有可能出现超时但无法继续执行的情况<br>如：URLConnection在使用时需要同时设置 `void setConnectTimeout(int timeout)` 和 `void setReadTimeout(int timeout)`，否则有可能在使用时出现客户端等待数据但网络连接一直保持的情况。使用HttpClient时也需要设置类似的两个参数(生产环境悲剧过，大家要引以为戒)。

==四、应用Load过高==
这种情况可以使用 `jtop` 查看，通过对堆栈对CPU使用量排序，查找出问题的Java代码。

==五、应用占用内存过高，发生OOME异常==
遇到这种问题我们首先需要判断是哪个区内存OOME。

JVM内存主要分为：
 # JVM管理的内存
  # Heap区内存
  # Perm区内存(JDK8开始将不再有Perm区)<br>主要是由Java类和字符串常量（或调用`String.intern()`）组成
  # Direct Buffer内存<br>间接通过GC管理，即当持有对应Direct Buffer的Java对象在回收时才会对其回收
 # 非JVM管理的内存
  # Native内存
   # 线程创建占用的内存
   # JNI程序占用的内存

可以通过 `jstat -gcutil` 查找各个代的使用情况。
|| `O + E + S0/1` || 表示Heap区 ||
|| P || 表示Perm区||

{{{
  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT   
  0.00 100.00   6.47   0.21  81.13      1    0.015     0    0.000    0.015
}}}
 * Heap区OOME
 Heap区对象创建过多，一般情况是程序的问题，也有可能是 `-Xmx` 大小设计过小。这种情况也可使用 `jtop` 查看，通过参数 `--sortmem` ，查找对的Java代码。还可以通过 `jmap -histo` 查找每个类的实例数据及占用的内存大小，也可通过 `histodiff` 查找该断时间内创建的对象情况。命令 `jmap -histo:live <PID>` 可以强制JVM做GC，通过多次这个命令可以看看内存中的对象是否会被回收。如果最终还是没有办法，可通过命令 `jmap -dump:format=b,file=<file name> <PID>` 将内存映象层出为文件，然后通过 `mat` 分析。
 * Perm区OOME
 正常情况下Perm区的大小应该大于`<size of lib> * 2` ，如你的lib大小为`80M`，则你的Perm需要设置`>160M`，生产环境应用一般设置`-XX:PermSize=256M`，当然具体需要视应用情况而定(需要分析应用占用Perm区的情况)。
  * 加载过多类，通过增加启动参数查找JVM加载了哪些类：
   * `-verbose:class` 相当于 `+TraceClassLoading,+TraceClassUnloading`
   * `+TraceClassLoading` 当类加载时打印日志
   日志格式则是 `类名 + 加载的jar包名字` ：
{{{
[Loaded sun.dc.pr.Rasterizer from /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar]
[Loaded sun.dc.pr.PathFiller from /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar]
[Loaded sun.dc.pr.PathDasher from /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar]
}}}
   而对于下面这些类(from 为 `__JVM_DefineClass__`)则是没有具体的jar包，GeneratedMethodAccessor相关的类则是类反射调用次数超过15次自JVM自动增强产生的，日志如下：
{{{
[Loaded sun.reflect.GeneratedMethodAccessor17 from __JVM_DefineClass__]
[Loaded sun.reflect.GeneratedMethodAccessor18 from __JVM_DefineClass__]
[Loaded sun.reflect.GeneratedMethodAccessor19 from __JVM_DefineClass__]
}}}
   * `+TraceClassUnloading` 当类卸载时打印日志
  也可通过`classdump` 或 `classlist` 列出加载的类的情况。
  * String.intern() 加载过多字符串
   * 通过 `permstat` 可以分析当前JVM中加载的String.intern()的情况
   * 对于动态加载情况可以通过 btrace 跟踪加载情况
 * Native OOME
  * `ZipOutputStream`使用时未关闭会引起native内存无法正常释放
  * `Font.createFont`函数创建的Font对象会Soft引用Native内存
 * Direct Buffer OOME
 通过 `directbufferana` 查看当前JVM的 Direct Buffer 使用情况，如命令 `java -jar directbufferanaall.jar <PID>` 输出：
{{{
NIO direct memory: (in bytes)
  reserved size = 0.014094 MB (14779 bytes)
  max size      = 123.937500 MB (129957888 bytes)
  malloc'd size = 0.014001 MB (14681 bytes)
}}}

===参考资料===
`[1].` [Study_Java_HotSpot_OOME]<br>
`[2].` [Study_Java_HotSpot_Arguments]<br>