#summary HotSpot问题诊断
#sidebar TableOfContents

=HotSpot问题诊断=
查找HotSpot相关的问题需要根据现象判断，对现象简单分类如下：

==HotSpot异常退出==
这个问题比较棘手，因为通常JVM异常退出是JVM自身的Bug，所以一般需要读懂JVM源代码才能够找到/解决这类Bug。

==加载的类似乎有问题==
常常在一个应用里有同一个jar包的不同版本，但我们无法断定当前JVM加载的是哪个版本，这时候可以通过 `classdump` 打印URLClassLoader中加载的所有jar包，并列出他们的顺序。而我们实现的使用场景中常常还会使用类增强的手段，如使用ASM、javasist等，这时候需要分析内存中的字节码，此时也可以使用 `classdump` 将对应的类输出到磁盘文件。

==应用停止处理业务逻辑==
这种情况需要查看服务器Load是不是Load过高导致不处理正常业务逻辑，参看 `[应用Load过高]` 或 `[应用占用内存过高]` 。如果Load正常且内存占用也正常则需要通过命令 `jstack` 查看堆栈情况，分析程序未正常工作的原因。此类情况有可能是：
 * 数据库锁，更新/查询/删除数据未提交
 * 程序死锁，不恰当的使用Lock
 * 网络IO操作未返回，如未设置超时时间且当网络异常时有可能出现超时但无法继续执行的情况<br>如：URLConnection在使用时需要同时设置 `void setConnectTimeout(int timeout)` 和 `void setReadTimeout(int timeout)`，否则有可能在使用时出现客户端等待数据但网络连接一直保持的情况。使用HttpClient时也需要设置类似的两个参数(生产环境悲剧过，大家要引以为戒)。

==应用Load过高==
这种情况可以使用 `jtop` 查看，通过对堆栈对CPU使用量排序，查找出问题的Java代码。

==应用占用内存过高，发生OOME异常==
遇到这种问题我们首先需要判断是哪个区内存OOME，可以通过 `jstat -gcutil` 查找各个代的使用情况。这种情况也可使用 `jtop` 查看，通过参数 `--sortmem` ，查找对的Java代码。还可以通过 `jmap -histo` 查找每个类的实例数据及占用的内存大小，也可通过 `histodiff` 查找该断时间内创建的对象情况。
 * Heap区OOME
 * Perm区OOME
  * 加载过多类，通过增加启动参数查找JVM加载了哪些类：
   * `-verbose:class` 相当于 `+TraceClassLoading,+TraceClassUnloading`
   * `+TraceClassLoading` 当类加载时打印日志
{{{
[Loaded sun.dc.pr.Rasterizer from /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar]
[Loaded sun.dc.pr.PathFiller from /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar]
[Loaded sun.dc.pr.PathDasher from /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar]
}}}
{{{
[Loaded sun.reflect.GeneratedSerializationConstructorAccessor11 from __JVM_DefineClass__]
[Loaded sun.reflect.GeneratedSerializationConstructorAccessor12 from __JVM_DefineClass__]
[Loaded sun.reflect.GeneratedSerializationConstructorAccessor13 from __JVM_DefineClass__]
[Loaded sun.reflect.GeneratedSerializationConstructorAccessor14 from __JVM_DefineClass__]
}}}
   * `+TraceClassUnloading` 当类卸载时打印日志
  也可通过`classdump` 或 `classlist` 列出加载的类的情况。
  * String.intern() 加载过多字符串
   * 通过 `permstat` 可以分析当前JVM中加载的String.intern()的情况
   * 对于动态加载情况可以通过 btrace 跟踪加载情况
 * Native OOME
  * `ZipOutputStream`使用时未关闭会引起native内存无法正常释放
  * `Font`
 * Direct Buffer OOME

===参考资料===
`[1].` [Study_Java_HotSpot_OOME]<br>