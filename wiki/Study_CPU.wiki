#summary CPU study


=X86=
X86或80X86，X86架构使用可变长度指令CISC(复杂指令集计算机,Complex Instruction Set Computer)。<br>
X86_32在Intel也称为IA32(Intel Architecture, 32-bit)，IA64

====通用寄存器====
|| *寄存器* || *描述* ||
|| `AX/EAX/RAX` || 一般用作累加器 ||
|| `BX/EBX/RBX` || 一般用作基址寄存器（Base，用于数组） ||
|| `CX/ECX/RCX` || 一般用来计数（Count） ||
|| `DX/EDX/RDX` || 一般用来存放数据（Data） ||
|| `SI/ESI/RSI` || 一般用作源变址（Source Index） ||
|| `DI/EDI/RDI` || 一般用作目标变址（Destinatin Index） ||
|| `SP/ESP/RSP` || 一般用作堆栈指针（Stack Pointer） ||
|| `BP/EBP/RBP` || 一般用作基址指针（Base Pointer） ||
|| `IP/EIP/RIP` || Instruction pointer. Holds the program counter, the current instruction address. ||

====段寄存器(Segment registers)====
|| *寄存器* || *描述* ||
|| CS || 代码段寄存器 ||
|| DS || 数据段寄存器 ||
|| SS || 堆栈段寄存器 ||
|| ES || 附加数据段寄存器 ||
|| FS || 附加数据段寄存器 ||
|| GS || 附加数据段寄存器 ||

====General Purpose Registers (`A, B, C and D`)====
<table border="1">
  <tr align="center"><th width="50">`64`</th><th width="50">`56`</th><th width="50">`48`</th><th width="50">`40`</th><th width="50">`32`</th><th width="50">`24`</th><th width="50">`16`</th><th width="50">`8`</th></tr>
  <tr align="center"><td colspan="8">`R?X`</td></tr>
  <tr align="center"><td colspan="4">`--`</td><td colspan="4">`E?X`</td></tr>
  <tr align="center"><td colspan="6">`--`</td><td colspan="2">`?X`</td></tr>
  <tr align="center"><td colspan="6">`--`</td><td>`?H`</td><td>`?L`</td></tr>
</table>
<br><br>

====64-bit mode-only General Purpose Registers (`R8, R9, R10, R11, R12, R13, R14, R15`)====
<table border="1">
  <tr align="center"><th width="50">`64`</th><th width="50">`56`</th><th width="50">`48`</th><th width="50">`40`</th><th width="50">`32`</th><th width="50">`24`</th><th width="50">`16`</th><th width="50">`8`</th></tr>
  <tr align="center"><td colspan="8">`?`</td></tr>
  <tr align="center"><td colspan="4">`--`</td><td colspan="4">`?D`</td></tr>
  <tr align="center"><td colspan="6">`--`</td><td colspan="2">`?W`</td></tr>
  <tr align="center"><td colspan="7">`--`</td><td>`?B`</td></tr>
</table>
<br><br>

====Segment Registers (`C, D, S, E, F and G`)====
<table border="1">
  <tr align="center"><th width="50">`16`</th><th width="50">`8`</th></tr>
  <tr align="center"><td colspan="2">`?S`</td></tr>
</table>
<br><br>

====Pointer Registers (`S and B`)====
<table border="1">
  <tr align="center"><th width="50">`64`</th><th width="50">`56`</th><th width="50">`48`</th><th width="50">`40`</th><th width="50">`32`</th><th width="50">`24`</th><th width="50">`16`</th><th width="50">`8`</th></tr>
  <tr align="center"><td colspan="8">`R?P`</td></tr>
  <tr align="center"><td colspan="4">`--`</td><td colspan="4">`E?P`</td></tr>
  <tr align="center"><td colspan="6">`--`</td><td colspan="2">`?P`</td></tr>
  <tr align="center"><td colspan="7">`--`</td><td>`?PL`^注1^</td></tr>
</table>
<br><br>

====Index Registers (`S and D`)====
<table border="1">
  <tr align="center"><th width="50">`64`</th><th width="50">`56`</th><th width="50">`48`</th><th width="50">`40`</th><th width="50">`32`</th><th width="50">`24`</th><th width="50">`16`</th><th width="50">`8`</th></tr>
  <tr align="center"><td colspan="8">`R?I`</td></tr>
  <tr align="center"><td colspan="4">`--`</td><td colspan="4">`E?I`</td></tr>
  <tr align="center"><td colspan="6">`--`</td><td colspan="2">`?I`</td></tr>
  <tr align="center"><td colspan="7">`--`</td><td>`?IL`^注1^</td></tr>
</table>
<br><br>

====Instruction Pointer Register (`I`)====
<table border="1">
  <tr align="center"><th width="50">`64`</th><th width="50">`56`</th><th width="50">`48`</th><th width="50">`40`</th><th width="50">`32`</th><th width="50">`24`</th><th width="50">`16`</th><th width="50">`8`</th></tr>
  <tr align="center"><td colspan="8">`R?P`</td></tr>
  <tr align="center"><td colspan="4">`--`</td><td colspan="4">`E?P`</td></tr>
  <tr align="center"><td colspan="6">`--`</td><td colspan="2">`?P`</td></tr>
</table>
<br><br>
^注1^: The `?PL` `?IL` registers are only available in 64-bit mode.
<br><br>


Addressing modes for 16-bit x86 processors can be summarized by this formula:
[http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/x86/addressing_mode_16bit.png]


Addressing modes for 32-bit address size on 32-bit or 64-bit x86 processors can be summarized by this formula:
[http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/x86/addressing_mode_32bit.png]


Addressing modes for 64-bit code on 64-bit x86 processors can be summarized by this formula:
[http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/x86/addressing_mode_64bit.png]

====Instruction suffixes ^[5]^====
|| *b* || byte |||| *w* || word (2 bytes) |||| *l* || long (4 bytes) ||

====Condition codes ^[5]^====
|| *CF* || Carry Flag |||| *ZF* || Zero Flag |||| *SF* || Sign Flag |||| *OF* || Overflow Flag ||

===IA32 Addressing modes ^[5]^===
====Immediate====
|| `$val Val` ||
|| val: constant integer value ||
|| `movl $17, %eax` ||

====Normal====
|| `(R) Mem[Reg[R]]` ||
|| R: register R specifies memory address |||| `movl (%ecx), %eax` ||

====Displacement====|| `D(R) Mem[Reg[R]+D]` |||| R: register specifies start of memory region |||| D: constant displacement D specifies offset |||| movl 8(%ebp), %edx ||

====Indexed====|| `D(Rb,Ri,S) Mem[Reg[Rb]+S*Reg[Ri]+D]` |||| D: constant displacement 1, 2, or 4 bytes |||| Rb: base register: any of 8 integer registers |||| Ri: index register: any, except %esp |||| S: scale: 1, 2, 4, or 8 |||| `movl 0x100(%ecx,%eax,4), %edx` ||

=Intel=


 * [http://ark.intel.com/ ARK | Your source for information on Intel products]
  * [http://en.wikipedia.org/wiki/Xeon Xeon] 
 * [ftp://download.intel.com/design/ Intl Design Download]
 * [http://en.wikipedia.org/wiki/List_of_Intel_Xeon_microprocessors List]
 * [http://en.wikipedia.org/wiki/List_of_Intel_microprocessors List of Intel microprocessors]
 * [http://en.wikipedia.org/wiki/List_of_future_Intel_microprocessors List of future Intel microprocessors]


===参考资料===
`[1].` http://zh.wikipedia.org/wiki/X86<br>
`[2].` http://en.wikipedia.org/wiki/X86<br>
`[3].` http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html<br>
`[4].` http://www.cs.virginia.edu/~evans/cs216/guides/x86.html<br>
`[5].` http://www.stanford.edu/class/cs107/other/IA32_Cheat_Sheet.pdf<br>
`[6].` http://en.wikipedia.org/wiki/Assembly_language<br>
