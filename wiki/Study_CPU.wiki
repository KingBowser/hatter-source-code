#summary CPU study
#sidebar TableOfContents

=brainiac vs speed-demon=

brainiac，追求instruction-level parallelism，speed-demon，追求更高的clock speed

http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/cpu/brainiac.vs.speed-demon.jpg

http://www.lighterra.com/papers/modernmicroprocessors/


----

=X86=
X86或80X86，X86架构使用可变长度指令CISC(复杂指令集计算机,Complex Instruction Set Computer)。<br>
X86_32在Intel也称为IA32(Intel Architecture, 32-bit)，IA64

====通用寄存器====
|| *寄存器* || *描述* ||
|| `AX/EAX/RAX` || 一般用作累加器 ||
|| `BX/EBX/RBX` || 一般用作基址寄存器（Base，用于数组） ||
|| `CX/ECX/RCX` || 一般用来计数（Count） ||
|| `DX/EDX/RDX` || 一般用来存放数据（Data） ||
|| `SI/ESI/RSI` || 一般用作源变址（Source Index） ||
|| `DI/EDI/RDI` || 一般用作目标变址（Destinatin Index） ||
|| `SP/ESP/RSP` || 一般用作堆栈指针（Stack Pointer） ||
|| `BP/EBP/RBP` || 一般用作基址指针（Base Pointer） ||
|| `IP/EIP/RIP` || Instruction pointer. Holds the program counter, the current instruction address. ||

====段寄存器(Segment registers)====
|| *寄存器* || *描述* ||
|| CS || 代码段寄存器 ||
|| DS || 数据段寄存器 ||
|| SS || 堆栈段寄存器 ||
|| ES || 附加数据段寄存器 ||
|| FS || 附加数据段寄存器 ||
|| GS || 附加数据段寄存器 ||

====General Purpose Registers (`A, B, C and D`)====
<table border="1">
  <tr align="center"><th width="50">`64`</th><th width="50">`56`</th><th width="50">`48`</th><th width="50">`40`</th><th width="50">`32`</th><th width="50">`24`</th><th width="50">`16`</th><th width="50">`8`</th></tr>
  <tr align="center"><td colspan="8">`R?X`</td></tr>
  <tr align="center"><td colspan="4">`--`</td><td colspan="4">`E?X`</td></tr>
  <tr align="center"><td colspan="6">`--`</td><td colspan="2">`?X`</td></tr>
  <tr align="center"><td colspan="6">`--`</td><td>`?H`</td><td>`?L`</td></tr>
</table>
<br><br>

====64-bit mode-only General Purpose Registers (`R8, R9, R10, R11, R12, R13, R14, R15`)====
<table border="1">
  <tr align="center"><th width="50">`64`</th><th width="50">`56`</th><th width="50">`48`</th><th width="50">`40`</th><th width="50">`32`</th><th width="50">`24`</th><th width="50">`16`</th><th width="50">`8`</th></tr>
  <tr align="center"><td colspan="8">`?`</td></tr>
  <tr align="center"><td colspan="4">`--`</td><td colspan="4">`?D`</td></tr>
  <tr align="center"><td colspan="6">`--`</td><td colspan="2">`?W`</td></tr>
  <tr align="center"><td colspan="7">`--`</td><td>`?B`</td></tr>
</table>
<br><br>

====Segment Registers (`C, D, S, E, F and G`)====
<table border="1">
  <tr align="center"><th width="50">`16`</th><th width="50">`8`</th></tr>
  <tr align="center"><td colspan="2">`?S`</td></tr>
</table>
<br><br>

====Pointer Registers (`S and B`)====
<table border="1">
  <tr align="center"><th width="50">`64`</th><th width="50">`56`</th><th width="50">`48`</th><th width="50">`40`</th><th width="50">`32`</th><th width="50">`24`</th><th width="50">`16`</th><th width="50">`8`</th></tr>
  <tr align="center"><td colspan="8">`R?P`</td></tr>
  <tr align="center"><td colspan="4">`--`</td><td colspan="4">`E?P`</td></tr>
  <tr align="center"><td colspan="6">`--`</td><td colspan="2">`?P`</td></tr>
  <tr align="center"><td colspan="7">`--`</td><td>`?PL`^注1^</td></tr>
</table>
<br><br>

====Index Registers (`S and D`)====
<table border="1">
  <tr align="center"><th width="50">`64`</th><th width="50">`56`</th><th width="50">`48`</th><th width="50">`40`</th><th width="50">`32`</th><th width="50">`24`</th><th width="50">`16`</th><th width="50">`8`</th></tr>
  <tr align="center"><td colspan="8">`R?I`</td></tr>
  <tr align="center"><td colspan="4">`--`</td><td colspan="4">`E?I`</td></tr>
  <tr align="center"><td colspan="6">`--`</td><td colspan="2">`?I`</td></tr>
  <tr align="center"><td colspan="7">`--`</td><td>`?IL`^注1^</td></tr>
</table>
<br><br>

====Instruction Pointer Register (`I`)====
<table border="1">
  <tr align="center"><th width="50">`64`</th><th width="50">`56`</th><th width="50">`48`</th><th width="50">`40`</th><th width="50">`32`</th><th width="50">`24`</th><th width="50">`16`</th><th width="50">`8`</th></tr>
  <tr align="center"><td colspan="8">`R?P`</td></tr>
  <tr align="center"><td colspan="4">`--`</td><td colspan="4">`E?P`</td></tr>
  <tr align="center"><td colspan="6">`--`</td><td colspan="2">`?P`</td></tr>
</table>
<br><br>
^注1^: The `?PL` `?IL` registers are only available in 64-bit mode.
<br><br>


Addressing modes for 16-bit x86 processors can be summarized by this formula:
[http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/x86/addressing_mode_16bit.png]


Addressing modes for 32-bit address size on 32-bit or 64-bit x86 processors can be summarized by this formula:
[http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/x86/addressing_mode_32bit.png]


Addressing modes for 64-bit code on 64-bit x86 processors can be summarized by this formula:
[http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/x86/addressing_mode_64bit.png]

====Instruction suffixes ^[5]^====
|| *b* || byte ||
|| *w* || word (2 bytes) ||
|| *l* || long (4 bytes) ||

====Condition codes ^[5]^====
|| *CF* || Carry Flag ||
|| *ZF* || Zero Flag ||
|| *SF* || Sign Flag ||
|| *OF* || Overflow Flag ||

===IA32 Addressing modes ^[5]^===
====Immediate====
|| `$val Val` ||
|| val: constant integer value ||
|| `movl $17, %eax` ||

====Normal====
|| `(R) Mem[Reg[R]]` ||
|| R: register R specifies memory address ||
|| `movl (%ecx), %eax` ||

====Displacement====
|| `D(R) Mem[Reg[R]+D]` ||
|| R: register specifies start of memory region ||
|| D: constant displacement D specifies offset ||
|| movl 8(%ebp), %edx ||

====Indexed====
|| `D(Rb,Ri,S) Mem[Reg[Rb]+S*Reg[Ri]+D]` ||
|| D: constant displacement 1, 2, or 4 bytes ||
|| Rb: base register: any of 8 integer registers ||
|| Ri: index register: any, except %esp ||
|| S: scale: 1, 2, 4, or 8 ||
|| `movl 0x100(%ecx,%eax,4), %edx` ||

==Processor affinity==
Processor affinity or CPU Pinning. CPU pinning enables mapping and unmapping entire virtual machines or a specific virtual CPU (vCPU), to a physical CPU or a range of CPUs. ^[7]^


===参考资料===
`[1].` http://zh.wikipedia.org/wiki/X86<br>
`[2].` http://en.wikipedia.org/wiki/X86<br>
`[3].` http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html<br>
`[4].` http://www.cs.virginia.edu/~evans/cs216/guides/x86.html<br>
`[5].` http://www.stanford.edu/class/cs107/other/IA32_Cheat_Sheet.pdf<br>
`[6].` http://en.wikipedia.org/wiki/Assembly_language<br>
`[7].` http://en.wikipedia.org/wiki/Processor_affinity<br>