#summary CLI Memory Model
#sidebar TableOfContents

What is a memory model?  It’s the abstraction that makes the reality of today’s exotic hardware comprehensible to software developers.

The reality of hardware is that CPUs are renaming registers, performing speculative and out-of-order execution, and fixing up the world during retirement.  Memory state is cached at various levels in the system (L0 thru L3 on modern X86 boxes, presumably with more levels on the way).  Some levels of cache are shared between particular CPUs but not others.  For example, L0 is typically per-CPU but a hyper-threaded CPU may share L0 between the logical CPUs of a single physical CPU.  Or an 8-way box may split the system into two hemispheres with cache controllers performing an elaborate coherency protocol between these separate hemispheres.  If you consider caching effects, at some level all MP (multi-processor) computers are NUMA (non-uniform memory access).  But there’s enough magic going on that even a Unisys 32-way can generally be considered as UMA by developers.


===参考资料===
`[1].` http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf<br>
`[2].` http://blogs.msdn.com/b/jaredpar/archive/2008/01/17/clr-memory-model.aspx<br>
`[3].` http://www.bluebytesoftware.com/blog/2008/06/13/VolatileReadsAndWritesAndTimeliness.aspx<br>
`[4].` http://blogs.msdn.com/b/cbrumme/archive/2003/05/17/51445.aspx<br>
`[5].` http://www.bluebytesoftware.com/blog/2007/11/10/CLR20MemoryModel.aspx<br>
`[6].` http://msdn.microsoft.com/en-us/magazine/cc163715.aspx<br>
`[7].` http://igoro.com/archive/volatile-keyword-in-c-memory-model-explained/<br>