#summary Concurrent in Java, HotSpot

现在的计算机的频率已经很难提升，但现在/将来的趋势是多核，如Nvidia的强大的GPU ^[8]^，Intel，ARM也在努力提升核心的数量。所以在现代计算机中，并发编程将成为趋势。

=Java内存模型(JMM, Java Memory Model)=

Java内存模型如图：　^[22]^<br>
[http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/java_memory_model.png]<br>

[TODO] ^[18][22]^

=伪共享(False Sharing)=

我更喜欢称之为“错误共享”，CPU(Intel 4 core)结构Sample： ^[16]^<br>
[http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/intel_4_core.png]<br><br>
内存在缓存系统中常以缓存行(cache line)为单位缓存。缓存行的大小则是2的指数，通常在 32~256 字节范围内，最常见的大小为 64 字节。伪共享则是一个术语，在同时修改相关缓存行的独立变量时，在不知不觉的情况下影响不同线程的性能表现。 ^[9]^<br>
详细图例如下：<br>
[http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/false_sharing.png]

=锁(Locking)=

在Java中通过锁来实现线程安全，Java通过monitorenter与monitorexit这两个控制多线程同步的bytecode原语实现锁，是JVM依赖操作系统互斥(mutex)来实现的，所以在JVM中锁的性能相对较大。互斥是一种会导致线程挂起，并在较短的时间内又需要重新调度回原线程的，是较为消耗资源的操作。 ^[13]^

==Java中对锁的优化==

Java对象头结构(Java Object Header) ^[10]^
{{{
 [Mark Word             ] 32/64 bits
 [Class Metadata Address] 32/64 bits
 [Array Length          ] 32/64 bits
 对象为两个字(Word)，数组为3个字(增加了一个Array Length)
 
 对象的 Mark Word，同步相关的状态(32 bits)：
 [ bitfields                                   ][ tag bits ]  [ state              ]
 -----------------------------------------------------------------------------------
 [ hash                  (25)][ age (4)][ 0 (1)][ 01    (2)]  [ unlocked           ]
 [ ptr to lock record                      (29)][ 00    (2)]  [ lightweight locked ]
 [ ptr to heavyweight record               (29)][ 00    (2)]  [ inflated           ]
 [                                         (29)][ 11    (2)]  [ marked for GC      ]
 [ thread id (23)][ epoch (2)][ age (4)][ 1 (1)][ 01    (2)]  [ biasable           ]
}}}

通过参数`-XX:+UseBiasedLocking`判断当前是否使用偏向锁（在JDK6，7中默认打开该参数），同步锁转换图如下： ^[17]^<br>
[http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/synchronization.gif]<br>

===自旋锁与自适应自旋(Spinning Locking & Adaptive Spinning)===
互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时 间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。 <br>
在JDK 1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间， 比如100个循环。另一方面，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机就会变得越来越“聪明”了。 ^[20]^

===轻量级锁(Lightweight Locking)===
早期的研究表明，在Java中的大部分锁是不存在竞争的，基于这个研究结果发明了轻量级锁（当发生竞争时则膨胀到重量组锁） ^[19]^。轻量级锁本意是为了减少多线程进入互斥的几率，并不是要替代互斥。它利用了CPU原语Compare-And-Swap(CAS，汇编指令CMPXCHG)，尝试在进入互斥前，进行补救。 ^[13]^

===偏向锁(Biased Locking)===
IBM位于东京的实验室发现，Java程序中的锁不但竞争很少，而且是不共享的，基于这个发现则发明了偏向锁 ^[20]^。<br>
偏向锁取消： ^[10]^<br>
1. 退回到轻量级锁<br>
2. 等待一个全局Safepoint（无字节码执行）<br>
3. 遍历线程栈，枚举锁信息<br>
4. 更新对象头锁信息<br>

===锁膨胀(Lock Coarsening)==
如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（膨胀）到整个操作序列的外部，这样只需要加锁一次就可以了。参数`-XX:+EliminateLocks`。 ^[14][21]^<br>
锁膨胀的例子如下 ^[12]^:
{{{
public Point moveNW (Point p) {
  synchronized (p) {
    p.x += 10;
  }
  synchronized (p) {
    p.y += 10;
  }
}

public Point moveNW (Point p) {
  synchronized (p) {
    p.x += 10;
    p.y += 10;
  }
}
}}}

===锁削除(Lock Elision through Escape Analysis)===
锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。锁削除的主要判定依据来源于逃逸分析（参数：-XX:+DoEscapeAnalysis）的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。 ^[14][21]^

>>>>>>>
内存屏障(Memory barrier)，也被称为 membar 、 memory fence 或 fence instruction，是一类强制CPU或编译器使用对内存有序操作的指令。 ^[15]^


>>>>>>>
Illusion: Locks are Fast ^11^
Contended locks obviously block and must involve the OS
 ● (Expect fairness from the OS)
Uncontended locks are a dozen nano's or so
 ● Biased locking: ~2-4 clocks (when it works)
 ● Very fast user-mode locks otherwise
Highly optimized because synchronized is so common

Most lockings are not only uncontended, but performed repeatedly by the same thread ^[10]^
>> Make it cheap for a single thread to reacquire a lock can be an optimization


===参数资料===
`[1].` http://www.infoq.com/cn/articles/zzm-java-hsdis-jvm<br>
`[2].` http://blog.csdn.net/fw0124/article/details/6672522<br>
`[3].` http://kenwublog.com/illustrate-memory-reordering-in-cpu<br>
`[4].` http://hi.baidu.com/ajf8/blog/item/05889719727b691934fa4178.html<br>
`[5].` http://www.langyuweb.com/a/wangluozhishi/2012/0326/14674.html<br>
`[6].` http://www.infoq.com/cn/articles/cf-java-thread<br>
`[7].` http://www.goldendoc.org/2011/05/juc/<br>
`[8].` http://cloud.csdn.net/a/20100926/279856.html<br>
`[9].` http://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html<br>
`[10].` http://edu.netbeans.org/contrib/slides/java-overview-and-java-se6.pdf<br>
`[11].` http://www.azulsystems.com/blog/wp-content/uploads/2011/03/2011_WhatDoesJVMDo.pdf<br>
`[12].` http://wiki.jvmlangsummit.com/pdf/10_Pampuch_vm_opts.pdf<br>
`[13].` http://kenwublog.com/theory-of-lightweight-locking-upon-cas<br>
`[14].` http://icyfenix.iteye.com/blog/1018932<br>
`[15].` http://en.wikipedia.org/wiki/Memory_barrier<br>
`[16].` http://jakub.wartak.pl/dl/j2ee/sunJVM-on-intel-multicoreservers.pdf<br>
`[17].` https://wikis.oracle.com/display/HotSpotInternals/Synchronization<br>
`[18].` http://en.wikipedia.org/wiki/Java_Memory_Model<br>
`[19].` http://www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf<br>
`[20].` https://code.google.com/p/hatter-source-code/wiki/Study_Java_HotSpot_Glossay<br>
`[21].` http://home.comcast.net/~pjbishop/Dave/MustangSync.pdf<br>
`[22].` http://www.javaol.net/2010/10/java-memory-model/<br>

