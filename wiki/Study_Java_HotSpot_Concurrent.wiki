#summary Concurrent in Java, HotSpot

现在的计算机的频率已经很难提升，但现在/将来的趋势是多核，如Nvidia的强大的GPU ^[8]^，Intel，ARM也在努力提升核心的数量。所以在现代计算机中，并发编程将成为趋势。

=Java内存模型(JMM, Java Memory Model)=
[TODO] ^[18]^

=伪共享(False Sharing)=

CPU(Intel 4 core)结构Sample： ^[16]^<br>
[http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/intel_4_core.png]<br><br>
内存在缓存系统中常以缓存行(cache line)为单位缓存。缓存行的大小则是2的指数，通常在 32~256 字节范围内，最常见的大小为 64 字节。伪共享则是一个术语，在同时修改相关缓存行的独立变量时，在不知不觉的情况下影响不同线程的性能表现。 ^[9]^<br>
详细图例如下：<br>
[http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/false_sharing.png]

=锁(Locking)=

在Java中通过锁来实现线程安全，Java通过monitorenter与monitorexit这两个控制多线程同步的bytecode原语实现锁，是JVM依赖操作系统互斥(mutex)来实现的，所以在JVM中锁的性能相对较大。互斥是一种会导致线程挂起，并在较短的时间内又需要重新调度回原线程的，是较为消耗资源的操作。 ^[13]^

==Java中对锁的优化==

Java对象头结构(Java Object Header) ^[10]^
{{{
 [Mark Word             ] 32/64 bits
 [Class Metadata Address] 32/64 bits
 [Array Length          ] 32/64 bits
 对象为两个字(Word)，数组为3个字(增加了一个Array Length)
 
 对象的 Mark Word，同步相关的状态(32 bits)：
 [ bitfields                                   ][ tag bits ]  [ state              ]
 -----------------------------------------------------------------------------------
 [ hash                  (25)][ age (4)][ 0 (1)][ 01    (2)]  [ unlocked           ]
 [ ptr to lock record                      (29)][ 00    (2)]  [ lightweight locked ]
 [ ptr to heavyweight record               (29)][ 00    (2)]  [ inflated           ]
 [                                         (29)][ 11    (2)]  [ marked for GC      ]
 [ thread id (23)][ epoch (2)][ age (4)][ 1 (1)][ 01    (2)]  [ biasable           ]
}}}

通过参数`-XX:+UseBiasedLocking`判断当前是否使用偏向锁（在JDK6，7中默认打开该参数），同步锁转换图如下： ^[17]^<br>
[http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/synchronization.gif]<br>

===自旋锁与自适应自旋(Spinning Locking & Adaptive Spinning)===
[TODO]

===轻量级锁(Lightweight Locking)===
轻量级锁本意是为了减少多线程进入互斥的几率，并不是要替代互斥。它利用了CPU原语Compare-And-Swap(CAS，汇编指令CMPXCHG)，尝试在进入互斥前，进行补救。 ^[13]^

===偏向锁(Biased Locking)===
[TODO]

===锁膨胀(Lock Coarsening)==
如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（膨胀）到整个操作序列的外部，这样只需要加锁一次就可以了。 ^[14]^<br>
锁膨胀的例子如下 ^[12]^:
{{{
public Point moveNW (Point p) {
  synchronized (p) {
    p.x += 10;
  }
  synchronized (p) {
    p.y += 10;
  }
}

public Point moveNW (Point p) {
  synchronized (p) {
    p.x += 10;
    p.y += 10;
  }
}
}}}


>>>>>>>
内存屏障(Memory barrier)，也被称为 membar 、 memory fence 或 fence instruction，是一类强制CPU或编译器使用对内存有序操作的指令。 ^[15]^

>>>>>>>


>>>>>>>
Illusion: Locks are Fast ^11^
Contended locks obviously block and must involve the OS
 ● (Expect fairness from the OS)
Uncontended locks are a dozen nano's or so
 ● Biased locking: ~2-4 clocks (when it works)
 ● Very fast user-mode locks otherwise
Highly optimized because synchronized is so common

Most lockings are not only uncontended, but performed repeatedly by the same thread ^[10]^
>> Make it cheap for a single thread to reacquire a lock can be an optimization

>>>>>>>
All modern JVMs incorporate light-weight locking
 > Avoid associating an OS mutex / condition variable (heavy-weight lock) with each object
Effective because most locking is uncontended – not competed by threads

TLAB 减少并发


===参数资料===
`[1].` http://www.infoq.com/cn/articles/zzm-java-hsdis-jvm<br>
`[2].` http://blog.csdn.net/fw0124/article/details/6672522<br>
`[3].` http://kenwublog.com/illustrate-memory-reordering-in-cpu<br>
`[4].` http://hi.baidu.com/ajf8/blog/item/05889719727b691934fa4178.html<br>
`[5].` http://www.langyuweb.com/a/wangluozhishi/2012/0326/14674.html<br>
`[6].` http://www.infoq.com/cn/articles/cf-java-thread<br>
`[7].` http://www.goldendoc.org/2011/05/juc/<br>
`[8].` http://cloud.csdn.net/a/20100926/279856.html<br>
`[9].` http://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html<br>
`[10].` http://edu.netbeans.org/contrib/slides/java-overview-and-java-se6.pdf<br>
`[11].` http://www.azulsystems.com/blog/wp-content/uploads/2011/03/2011_WhatDoesJVMDo.pdf<br>
`[12].` http://wiki.jvmlangsummit.com/pdf/10_Pampuch_vm_opts.pdf<br>
`[13].` http://kenwublog.com/theory-of-lightweight-locking-upon-cas<br>
`[14].` http://icyfenix.iteye.com/blog/1018932<br>
`[15].` http://en.wikipedia.org/wiki/Memory_barrier<br>
`[16].` http://jakub.wartak.pl/dl/j2ee/sunJVM-on-intel-multicoreservers.pdf<br>
`[17].` https://wikis.oracle.com/display/HotSpotInternals/Synchronization<br>
`[18].` http://en.wikipedia.org/wiki/Java_Memory_Model<br>


