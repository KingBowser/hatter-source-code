#summary HotSpot OutOfMemoryError解析

在JVM中内存一共有3种：Heap（堆内存），Non-Heap（非堆内存） ^[3]^和Native（本地内存）。

Heap memory is the runtime data area from which memory for all class instances and arrays is allocated. Non-heap memory includes the method area and memory required for the internal processing or optimization of the JVM. It stores per-class structures such as a runtime constant pool, field and method data, and the code for methods and constructors. Native memory is the virtual memory managed by the operating system. When the memory is insufficient for an application to allocate, a java.lang.OutOfMemoryError will be thrown.


|| *问题* || *表象* || *诊断工具* ||
|| 内存不足 || `OutOfMemoryError` || `Java Heap Analysis Tool(jhat)` ^[4]^<br>`Eclipse Memory Analyzer` ^[5]^ ||
|| 内存泄漏 || 使用内存增长，频繁GC || `Java Monitoring and Management Console(jconsole)` ^[6]^<br>`JVM Statistical Monitoring Tool(jstat)` ^[7]^ ||
|| ` ` || 一个类有大量的实例 || `Memory Map(jmap) - "jmap -histo"` ^[8]^ ||
|| ` ` || 对象被误引用 || `jconsole` ^[6]^ 或 `jmap -dump + jhat` ^[8][4]^ ||
|| `Finalizers` || 对象等待结束 || `jconsole` ^[6]^ 或 `jmap -dump + jhat` ^[8][4]^ ||

当Java进度无法分配足够内存运行时将会抛出OutOfMemoryError：
 1. *`java.lang.OutOfMemoryError: Java heap space`*
 <code language="Java">List<String> list = new ArrayList<String>();
while(true) list.add(new String("Consume more memory!"));</code>
 2. *`java.lang.OutOfMemoryError: PermGen space`*
 <code language="Java">List<Class<?>> classes = new ArrayList<Class<?>>();
while(true){
    MyClassLoader cl = new MyClassLoader();
    try{
        classes.add(cl.loadClass("Dummy"));
    }catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}</code>
 <code language="Java">List<String> list = new ArrayList<String>();
int i=0;
while(true) list.add(("Consume more memory!"+(i++)).intern());
 </code>
 3. *`java.lang.OutOfMemoryError: unable to create new native thread`*
 在JVM中每启动一个线程都会分配一块本地内存，用于存放线程的调用栈，该空间仅在线程结束时释放。当没有足够本地内存创建线程时就会出现该错误。通过以下代码可以很容易再现该问题：
 <code language="Java">while(true){
    new Thread(new Runnable(){
        public void run() {
            try {
                Thread.sleep(60*60*1000);
            } catch(InterruptedException e) { }        
        }    
    }).start();
}</code>
 4. *`java.lang.OutOfMemoryError: Direct buffer memory`*
 <code language="Java">List<ByteBuffer> list = new ArrayList<ByteBuffer>();
while(true) list.add(ByteBuffer.allocateDirect(10000000)); </code>
 5. *`java.lang.OutOfMemoryError: request <size> bytes for <reason>.`*
 
===参考资料===
`[1].` http://java.sun.com/developer/technicalArticles/J2SE/monitoring/<br>
`[2].` http://eyalsch.wordpress.com/2009/06/17/oome/<br>
`[3].` http://docs.oracle.com/javase/6/docs/api/java/lang/management/MemoryType.html<br>
`[4].` http://java.sun.com/javase/6/docs/technotes/tools/share/jhat.html<br>
`[5].` http://www.eclipse.org/mat/<br>
`[6].` http://docs.oracle.com/javase/6/docs/technotes/tools/share/jconsole.html<br>
`[7].` http://docs.oracle.com/javase/6/docs/technotes/tools/share/jstat.html<br>
`[8].` http://java.sun.com/javase/6/docs/technotes/tools/share/jmap.html<br>

