#summary HotSpot OutOfMemoryError解析

在JVM中内存一共有3种：Heap（堆内存），Non-Heap（非堆内存） ^[3]^和Native（本地内存）。

堆内存是运行时分配所有类实例和数组的一块内存区域。非堆内存包含方法区和JVM内部处理或优化所需的内存，存放有类结构（如运行时常量池、字段及方法结构，以及方法和构造函数代码）。本地内存是由操作系统管理的虚拟内存。当一个应用内存不足时就会抛出 `java.lang.OutOfMemoryError` 异常。

|| *问题* || *表象* || *诊断工具* ||
|| 内存不足 || `OutOfMemoryError` || `Java Heap Analysis Tool(jhat)` ^[4]^<br>`Eclipse Memory Analyzer(mat)` ^[5]^ ||
|| 内存泄漏 || 使用内存增长，频繁GC || `Java Monitoring and Management Console(jconsole)` ^[6]^<br>`JVM Statistical Monitoring Tool(jstat)` ^[7]^ ||
|| ` ` || 一个类有大量的实例 || `Memory Map(jmap) - "jmap -histo"` ^[8]^ ||
|| ` ` || 对象被误引用 || `jconsole` ^[6]^ 或 `jmap -dump + jhat` ^[8][4]^ ||
|| `Finalizers` || 对象等待结束 || `jconsole` ^[6]^ 或 `jmap -dump + jhat` ^[8][4]^ ||

当Java进度无法分配足够内存运行时将会抛出OutOfMemoryError：
 1. *`java.lang.OutOfMemoryError: Java heap space`*
 堆内存溢出时，首先判断当前最大内存是多少（参数：`-Xmx` 或 `-XX:MaxHeapSize=`），可以通过命令 `jinfo -flag MaxHeapSize` ^[9]^查看运行中的JVM的配置，如果该值已经较大则应通过 mat ^[5]^ 之类的工具查找问题，或 `jmap -histo` ^[8]^查找哪个或哪些类占用了比较多的内存。
 下面代码可再现该异常：
 <code language="Java">List<String> list = new ArrayList<String>();
while(true) list.add(new String("Consume more memory!"));</code>
 2. *`java.lang.OutOfMemoryError: PermGen space`*
 <code language="Java">List<Class<?>> classes = new ArrayList<Class<?>>();
while(true){
    MyClassLoader cl = new MyClassLoader();
    try{
        classes.add(cl.loadClass("Dummy"));
    }catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}</code>
 <code language="Java">List<String> list = new ArrayList<String>();
int i=0;
while(true) list.add(("Consume more memory!"+(i++)).intern());
 </code>
 3. *`java.lang.OutOfMemoryError: unable to create new native thread`*
 在JVM中每启动一个线程都会分配一块本地内存，用于存放线程的调用栈，该空间仅在线程结束时释放。当没有足够本地内存创建线程时就会出现该错误。通过以下代码可以很容易再现该问题：
 <code language="Java">while(true){
    new Thread(new Runnable(){
        public void run() {
            try {
                Thread.sleep(60*60*1000);
            } catch(InterruptedException e) { }        
        }    
    }).start();
}</code>
 4. *`java.lang.OutOfMemoryError: Direct buffer memory`*
 <code language="Java">List<ByteBuffer> list = new ArrayList<ByteBuffer>();
while(true) list.add(ByteBuffer.allocateDirect(10000000)); </code>
 5. *`java.lang.OutOfMemoryError: request <size> bytes for <reason>.`*
 
===参考资料===
`[1].` http://java.sun.com/developer/technicalArticles/J2SE/monitoring/<br>
`[2].` http://eyalsch.wordpress.com/2009/06/17/oome/<br>
`[3].` http://docs.oracle.com/javase/6/docs/api/java/lang/management/MemoryType.html<br>
`[4].` http://docs.oracle.com/javase/6/docs/technotes/tools/share/jhat.html<br>
`[5].` http://www.eclipse.org/mat/<br>
`[6].` http://docs.oracle.com/javase/6/docs/technotes/tools/share/jconsole.html<br>
`[7].` http://docs.oracle.com/javase/6/docs/technotes/tools/share/jstat.html<br>
`[8].` http://docs.oracle.com/javase/6/docs/technotes/tools/share/jmap.html<br>
`[9].` http://docs.oracle.com/javase/6/docs/technotes/tools/share/jinfo.html<br>

