#summary Programming
#sidebar TableOfContents

|| *DATETYPE* || *LP32* || *ILP32* || *LP64* || *ILP64* || *LLP64* || *JAVA* || *C#* ||
|| `CHAR`  || 8 || 8 || 8 || 8 || 8 || 16 || 16 ||

 上表中，LP64、ILP64、LLP64是64位平台上字长的数据模型，ILP32和LP32是32位平台上字长的数据模型。
 * LP64指的是LONG/POINTER字长为64位；
 * ILP64指的是INT/LONG/POINT字长为64位；
 * LLP64指的是LONGLONG/POINTER字长为64位；
 * ILP32指的是INT/LONG/POINTER字长为32位；
 * LP32指的是LONG/POINT字长是32位的，INT字长为16位。<br>
^注1^：32位Windows采用的是ILP32数据模型，64位Windows采用LLP64数据模型。<br>
^注2^：32位的Linux/Unix使用ILP32数据模型，64位Linux/Unix使用LP64数据模型。<br>
^注3^：为了增加代码的移植性，打印无符号整形数，不管申明时是如何定义的，统一使用 %lu。<br>
^注4^：为了保证平台的通用性，代码中尽量不要使用long数据库型。<br>
^注5^：使用INT时也可以使用intptr_t来保证平台的通用性，它在不同的平台上编译时长度不同，但都是标准的平台长度，比如：64位机器上长度为8字节，32位机器上长度为4字节。<br>
^注6^：编写代码时要尽量使用sizeof来计算数据类型的大小。<br>
^注7^：ssize_t和size_t分别是signsize_t和unsigned signed size of computer word size。它们也是表示计算机的字长，在32位机器上是int型，在64位机器上long型，从某种意义上来说它们等同于intptr_t和 uintptr_t。

==支持协程的常见的语言和平台^[1]^==
|| *语言/平台* || *实现时间* || *协程名称* || *备注 ||
|| `GoLang` || 原生支持 || `goroutines` ||  ||
|| `Erlang` || 原生支持 || `process` || 函数式语言 ||
|| `Scala` || 原生支持 || `actor` || 函数式编程 ||
|| `Python` || 2.5版本后 || `coroutine` || 官方Python不完全实现<br>Stackless Python支持 ||
|| `Perl` || 6.0版本后 || `coroutine` ||  ||
|| `Ruby` || 1.9 版本后 || `fiber` ||  ||
|| `Lua` || 原生支持 || `coroutine` ||  ||
|| `C#` || .net 2.0版本后 || `fiber` ||  ||



===参考资料===
`[1].` http://www.yankay.com/go-clear-concurreny/<br>
`[2].` http://www.blogjava.net/jxlazzw/archive/2012/11/30/392280.html<br>