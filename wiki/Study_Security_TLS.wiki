#summary TLS Secure TCP/HTTP
#sidebar TableOfContents

 * https://www.openssl.org/
 * http://gnutls.org/
 * http://www.trevp.net/tlslite/ [https://github.com/trevp/tlslite GitHub]
 * http://www.bouncycastle.org/
 * https://istlsfastyet.com/
 * http://dev.chromium.org/Home/chromium-security/education/tls
 * http://chimera.labs.oreilly.com/books/1230000000545/ch04.html

==[https://cabforum.org/ CA/Browser Forum]==

SSL/TLS Test Tool:
 * [https://www.ssllabs.com/ssltest/index.html]
 * [https://www.wormly.com/test_ssl]


{{{
sudo openssl req -new -x509 -days 3650 -nodes -out cert.pem -keyout key.pem

* openssl req -new
用 OpenSSL 套件生成新的证书请求
* -x509
使用 X.509（PEM 编码的一种实现）
* -days 3650
有效期是十年，可以自己改
* -nodes
这个不是英文单词 “nodes”，而是 “No DES” 的意思，代表不用 DES 加密私钥，否则私钥默认是用 DES 加密的，每次启动 Apache 要输入密码
* -out
证书（包括证书信息和公钥）的文件名
* -keyout
私钥的文件名，如果此项和上一项同名的话，那么公钥和私钥是合并在同一文件里的（正如上面所贴的）

执行这个命令会让你输入一系列信息，比如 Common Name (CN)、公司名、地理位置、联系方式等，
除了 CN 必须要和网站域名匹配之外，其他可以按照你的喜好自由填写……
}}}

{{{
私钥：
openssl genrsa 2048 > ssl.key

* openssl genrsa 2048
显然就是用 OpenSSL 来生成一个 2048 位 RSA 加密的私钥（Generate RSA），这个位数是可以改的
* > ssl.key
这个是通过重定向命令，把生成的东西保存到 ssl.key 这个文件中。我的文件命名习惯上面提过了……

生成证书请求的命令是这个：
openssl req -new -key ssl.key > ssl.csr
}}}

{{{
DER 是內容為二進位碼的證書，而 PEM 則是 Base64 編碼加上特定檔頭的證書。 這兩者可以互轉。

openssl x509 -in x509.crt -inform DER -out x509.pem -outform PEM

openssl x509 -text -in mycert.pem
}}}

----
在Go语言中使用HTTPS：
{{{
import (
	"log"
	"net/http"
)

func handler(w http.ResponseWriter, req *http.Request) {
	w.Header().Set("Content-Type", "text/plain")
	w.Write([]byte("This is an example server.\n"))
}

func main() {
	http.HandleFunc("/", handler)
	log.Printf("About to listen on 10443. Go to https://127.0.0.1:10443/")
	err := http.ListenAndServeTLS(":10443", "cert.pem", "key.pem", nil)
	if err != nil {
		log.Fatal(err)
	}
}
}}}

----
With wget : OpenSSL: error:14077438:SSL routines:SSL23_GET_SERVER_HELLO:tlsv1 alert internal error

With curl : curl: (35) error:14077438:SSL routines:SSL23_GET_SERVER_HELLO:tlsv1 alert internal error


In wget, this can be fixed by specifying --secure-protocol=sslv3 option

In curl, this can be fixed by specifying -sslv3 option

----
{{{
wget --secure-protocol=sslv3 --no-check-certificate <URL>
curl -sslv3 -k <URL>
}}}

----
OpenSSL Command-Line HOWTO:
{{{
http://www.madboa.com/geek/openssl/
}}}

----
SNI - http://wiki.apache.org/httpd/NameBasedSSLVHostsWithSNI

http://blog.cloudflare.com/announcing-keyless-ssl-all-the-benefits-of-cloudflare-without-having-to-turn-over-your-private-ssl-keys/

[http://hatter-source-code.googlecode.com/svn/trunk/attachments/wiki/security/ssl/keyless-comic-v1.gif]

===参考资料===
`[1].` https://wzyboy.im/post/799.html<br>
`[2].` http://golang.org/pkg/net/http/#ListenAndServeTLS<br>
`[3].` http://www.xinotes.org/notes/note/1094/<br>
`[4].` https://help.ubuntu.com/10.04/serverguide/certificates-and-security.html<br>
`[5].` http://blog.roodo.com/rocksaying/archives/16158079.html<br>
`[6].` http://www.madboa.com/geek/openssl/<br>